<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Astarisx Documentation</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow-night-bright.min.css">
  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
    <!--<![endif]-->

</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>

    <div id="menu">
        <div class="pure-menu pure-menu-open">
            
            <a class="pure-menu-heading" href="../index.html"><span class="fa fa-arrow-left"></span>Astarisx</a>

            <ul>
                <li><a data-scroll href="#concepts">Concepts</a></li>
                <li class="sub"><a data-scroll href="#mvvm">MVVM Pattern</a></li>
                <li class="sub"><a data-scroll href="#anatomy">Application Anatomy</a></li>
                <li class="sub"><a data-scroll href="#dataflow">Unidirectional Data Flow</a></li>

                <li><a data-scroll href="#guides">Guides</a></li>
                <li class="sub"><a data-scroll href="#gettingstarted">Getting Started</a></li>
                <li class="sub"><a data-scroll href="#descriptors">Descriptors</a></li>
                <!-- specs | fields -kind -aliasFor -validate -viewModel | methods -->
                <li class="sub"><a data-scroll href="#datacontextsandstate">Data Contexts and $state</a></li>
                
                <li class="sub"><a data-scroll href="#setState">setState and Transtioning State</a></li>
                <!-- Directives need to be part of this -->
                <li class="sub"><a data-scroll href="#models">Models</a></li>
                <li class="sub"><a data-scroll href="#viewmodels">ViewModels</a></li>
                <li class="sub"><a class="wrap" data-scroll href="#controllerviewmodel">The ControllerViewModel</a></li>

                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Initialising Data Contexts</a></li>
                <li class="sub"><a data-scroll href="#initialisingdatacontexts">The UI and Views</a></li>
                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Watched State</a></li>
                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Working With The Router</a></li>
                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Media Query Notifications</a></li>
                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Optimizing the View</a></li>
                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Animation</a></li>
                
                <li><a data-scroll href="#tips">Tips</a></li>
                <li class="sub"><a data-scroll href="#deleting">Deleting</a></li>
                <li class="sub"><a data-scroll href="#undoredo">undo redo</a></li>
                <!-- <li class="sub"><a data-scroll href="#directives">Directives</a></li> -->

<!--                 <li class="sub"><a data-scroll href="#immutability">Immutability</a></li> -->
                <!-- The Application Data Context and how it works -> Properties etc.
                    Working with Models
                    Working with Arrays
                    Multiple Models
                    Undo/Redo Tips
                    watchedState Object
                    router object
                    MediaQuery
                    Animation
                 -->

                <!-- <li class="menu-item-divided pure-menu-selected">
                    <a href="#">Services</a>
                </li> -->
                <li>
                    <a data-scroll href="#browser">Browser Support</a>
                </li>
            </ul>
        </div>
    </div>

    <div id="main">
        <div class="header">
            <h1>Astarisx Developer's Guide</h1>
        </div>

        <div class="content">
            
            <h2 class="content-subhead" id="concepts"><a>Concepts</a></h2>
             <h3 class="content-subhead" id="mvvm"><a>MVVM Pattern</a></h3>
            <p>
                Astarisx helps implement the Model-View-ViewModel pattern, which is a specialization of the <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> developed by Microsoft in 2005 to leverage WPF and Silverlight technologies. John Gossman, one of the Architects of WPF and Silverlight at Microsoft during that time, coined the term. <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">WPF Apps With The Model-View-ViewModel Design Pattern</a> by Josh Smith, explains the pattern and its history if you're interested. Another article I would recommend is Addy Osmani's <a href="http://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/">Understanding MVVM â€“ A Guide For JavaScript Developers</a>. He does a great job at explaining MVVM for the JavaScript developer.

                Anyway, what does this mean for Astarisx. Well, in a nut shell, the MVVM pattern allows you to write Business Logic that is completely sepearate from the View.

                A quote from WPF Apps With The Model-View-ViewModel Design Pattern summarizes MVVM nicely.
                </p>
                <blockquote>
                    <p>
                        ... a ViewModel does not need a reference to a view. The view binds to properties on a ViewModel, which, in turn, exposes data contained in model objects and other state specific to the view. The bindings between view and ViewModel are simple to construct because a ViewModel object is set as the DataContext of a view. If property values in the ViewModel change, those new values automatically propagate to the view via data binding. When the user clicks a button in the View, a command on the ViewModel executes to perform the requested action. The ViewModel, never the View, performs all modifications made to the model data. The view classes have no idea that the model classes exist, while the ViewModel and model are unaware of the view. In fact, the model is completely oblivious to the fact that the ViewModel and view exist. This is a very loosely coupled design, which pays dividends in many ways ...
                    </p>
                    <footer>
                        <cite><a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">Josh Smith</a></cite>
                    </footer>
                </blockquote>
                <p>
                In addition to the above.
                </p>
                <blockquote>
                    <p>... the [ViewModel] will observe the view and respond to events by changing any appropriate state and reloading the entire view.</p>
                    <footer>
                        <cite><a href="http://martinfowler.com/eaaDev/PresentationModel.html">Martin Fowler</a></cite>
                    </footer>
                </blockquote>
                <p>
                    So in the context of Astarisx, React components act as the View, "data binding" is one-way and a "command" on the ViewModel is simply referred to as an action.

                    Astarisx also includes a specialized ViewModel, referred to as the ControllerViewModel. The ControllerViewModel determines which ViewModels are exposed to the View.
                </p>
            <h3 class="content-subhead" id="anatomy"><a>Application Anatomy</a></h3>
            <div class="pure-g">
                <div class="pure-u-1">
                    <img class="pure-img-responsive" src="../img/common/Astarisx.png" alt="Anatomy">
                </div>
            </div>
            <h4 class="content-subhead">Models</h4>
            <p>
                Yes, I know, you don't really need Models in React Applications. But these Models will really help simplify how your React application interacts with your data.

                So, for those unfamiliar with the concept, a Model is a abstraction of your application's data domain. What this means is that a Model represents a real entity, like a Person, Bank Account or Shopping Cart Item and it encapsulates the current state of that entity. Sometimes Models map nicely to a record/object in a data store, but more often then not, they don't. A Model can include domain logic, such as a save function or field validation and other Model specific logic.

                Astarisx Models are immutable. Meaning they can't be changed after they've been created. This ensures that the View, or any part of the application, doesn't go and change (mutate) an object they weren't supposed to potentially breaking your application and causing bugs.

                That's not to say that you can't change your data, you can. Astarisx makes it easy. You won't even know you're using immutable objects. Essentially, a Model's fields are exposed to the View and to update a Model you simply assign the new value to the field. For example to update a Person's name you would write something like <code class="wrap">this.state.appContext.people.currPerson.name = "Fred"</code>. This triggers the Application State to transition to a new state which includes your updated Model.

                A Model has no knowledge of the View or ViewModels. Whenever a Model changes state, a ViewModel is notified. It receives the model's new state and handles transitioning the model to the next state.
            </p>
            <h4 class="content-subhead">The ControllerViewModel</h4>
            <p>
                Every Astarisx application will have a ControllerViewModel. The ControllerViewModel is a specilialized ViewModel and is the entry point to your Astarisx application. It's responsibility is to manage and store Application State. This is where you define application level logic. The sort of things you might define in the ControllerViewModel may be application navigation, undo functionality or the application's online or busy status.

                The ControllerViewModel exposes ViewModels and all the methods and fields defined in the ControllerViewModel to the View. This is referred to as the Application Data Context.

                <!-- See ControllerViewModel -->
            </p>
            <h4 class="content-subhead">ViewModels</h4>
            <p>
                A ViewModel is where you define Business Logic and store View State. All methods and fields defined in a ViewModel are visible in the View via the ControllerViewModel. A ViewModel is also responsible for exposing Models, and consequently their methods and fields, to the View.

                It is common practice, when applying the Model-View-ViewModel pattern, to have a one to one relationship between a View and a ViewModel (i.e. one ViewModel represents a specific View's model, hence the name ViewModel). However, Astarisx doesn't require this. It is possible to have multiple Views share one or more ViewModels.

                The associated methods, fields and Models exposed by a ViewModel to the View, is referred to as a Data Context and forms part of the Application Data Context. A View interacts with a Data Context, invoking Actions, which are subsequently handled by the appropriate Model, ViewModel or ControllerViewModel resulting in a state transition.

                <!-- See ViewModels -->
            </p>
            <h4 class="content-subhead">The UI Container</h4>
            <p>
                React uses a single component to host all of the application's components. This component is at the apex of the component hierarchy. Astarisx refers to this component as the UI Container. The UI Container can hold regular React components and/or Astarisx Views. The UI Container receives a copy of the entire Application Data Context whenever there is a state change anywhere in the application.
            </p>
            <h4 class="content-subhead">Views</h4>
            <p>
                An Astarisx View is a self contained React component. They differ from regular React components in that they are stateless and completely decoupled from their Owner. Every View gets its own copy of the Application Data Context. Astarisx is capable of displaying multiple Views in the UI at any one time. These Views are also capable and most likely to contain any number of Views themselves.

                An Astarisx View is free to move around, within the application, without breaking functionality. It gets its own copy of the Application Data Context and receives a new copy whenever there is a state change within the application. State change notifications are sent to Mounted Views and can be easily configured for UI performance optimization, to only notify specific Views when specific state changes occur.

                <!-- See Views -->
            </p>
            <h4 class="content-subhead">State Manager</h4>
            <p>
                Astarisx takes on the responsibility of storing and managing the Application's State. Models, ViewModels and the ControllerViewModel store and manager their own state. The State Manager receives state change notifications from these objects, merges their state and transtions the application to the next state, the output being the Application Data Context. The Application Data Context is available to all Views and always holds the most current version of the Application's state. A View can interact with the Application Data Context, invoking Actions which are subsequently handled by the appropriate Model, ViewModel or the ControllerViewModel. The State Manager will then notify the Views of any state changes and pass them the latest Application Data Context. The State Manager is a system object. You don't need to create one of these.
                <!-- See Views -->
            </p>
           
            <h3 class="content-subhead" id="dataflow"><a>Unidirectional Data Flow</a></h3>

            <div class="pure-g">
                <div class="pure-u-1">
                    <img class="pure-img-responsive" src="../img/common/unidata.png" alt="Unidirectional Data Flow">
                </div>
            </div>
            <p>Astarisx application data flows are unidirectional. A View will invoke an Action, usually via User interactions on the UI, which gets handled by a Data Context. Data, or state, then flows out to the State Manager. The State Manager merges this state with the current Application State, effectively transitioning the Application Data Context to the next state. It then notifies all Views that state has changed and sends them the new Application Data Context. The Views propagate any changes down through to its components.</p>

            <h2 class="content-subhead" id="guides"><a>Guides</a></h2>
            <h3 class="content-subhead" id="gettingstarted">Getting Started</h3>

            <h4 class="content-subhead">Stand-alone </h4>
            <p>
            "Astarisx" is exposed as a global variable.
            <a href="https://github.com/entrendipity/astarisx/archive/master.zip">Download it.</a>
            </p>
            <pre><code><div class="code-block">&lt;script src="astarisx.min.js"&gt;&lt;/script&gt;</div></code></pre>


            <h4 class="content-subhead">Bower</h4>
            <pre><code><div class="code-block">$ <b>bower</b> install astarisx</div></code></pre>

            <h4 class="content-subhead">CommonJS</h4>
              <pre><code><div class="code-block">$ npm install astarisx</div></code></pre>

            <h4 class="content-subhead">AMD</h4>
<pre><code><div class="code-block">require(['./astarisx.min.js'], function(Astarisx){
  // Do something with Astarisx
});</div></code></pre>


            <h3 class="content-subhead" id="descriptors"><a>Descriptors</a></h3>
            <p>Descriptors are used to define Model, ViewModel or ControllerViewModel behavior. Behaviors are able to be defined using specification functions or mixins, fields and methods.</p>
            <h4 class="content-subhead"><a>Mixins</a></h4>
            <p>Mixins enable sharing and extending behavior and are used much the same as you use them in React. </p>
            <p>An exmple of sharing behavior is</p>
            <p>Extending behavior is</p>
            <h4 class="content-subhead"><a>Functions</a></h4>
            <p>Specification functions are predefined functions used to perform specific functions or provide configuration information for your application. These functions are invoked by Astarisx during the life cycle of an object.</p>
            <h4 class="content-subhead"><a>Fields</a></h4>
            <h4 class="content-subhead"><a>Methods</a></h4>

            <h2 class="content-subhead" id="browser"><a>Browser Support</a></h2>
            <p>Most ECMAScript 5 compliant browsers.</p>

            <p><b>IE8 and below is not supported.</b></p>

            <p><b>IE9 and below is not supported if the pushState option is enabled.</b></p>
            
        </div>
    </div>
</div>



<script src="../lib/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="js/ui.js"></script>
<script src="../lib/smooth-scroll.js"></script>
<script>
    smoothScroll.init({
      speed: 1000, // Integer. How fast to complete the scroll in milliseconds
    easing: 'easeInOutCubic', // Easing pattern to use
    // updateURL: false, // Boolean. Whether or not to update the URL with the anchor hash on scroll
    // offset: 80, // Integer. How far to offset the scrolling anchor location in pixels
    // callbackBefore: function ( toggle, anchor ) {}, // Function to run before scrolling
    // callbackAfter: function ( toggle, anchor ) {} // Function to run after scrolling
    });
</script>


</body>
</html>
