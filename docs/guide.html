<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Astarisx Documentation</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow-night-bright.min.css">
  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
    <!--<![endif]-->

</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>

    <div id="menu">
        <div class="pure-menu pure-menu-open">
            
            <a class="pure-menu-heading" href="../index.html"><span class="fa fa-arrow-left"></span>Astarisx</a>

            <ul>
                <li class="group-header"><a data-scroll href="#concepts">Concepts</a></li>
                <li class="sub"><a data-scroll href="#mvvm">MVVM Pattern</a></li>
                <li class="sub"><a data-scroll href="#anatomy">Application Anatomy</a></li>
                <li class="sub"><a data-scroll href="#dataflow">Unidirectional Data Flow</a></li>

                <li class="group-header"><a data-scroll href="#guides">Guides</a></li>
                <li class="sub"><a data-scroll href="#gettingstarted">Getting Started</a></li>
                <li class="sub"><a data-scroll href="#descriptors">Descriptors</a></li>
                <!-- specs | fields -kind -aliasFor -validate -viewModel | methods -->
                <li class="sub"><a data-scroll href="#fieldattributes">Field Attributes</a></li>
                <li class="sub"><a data-scroll href="#datacontextsandstate">Data Contexts and $state</a></li>
                
                <li class="sub"><a data-scroll href="#setstate">setState and Transitioning State</a></li>
                <!-- Directives need to be part of this -->
                <li class="sub"><a data-scroll href="#models">Models</a></li>
                <li class="sub"><a data-scroll href="#viewmodels">ViewModels</a></li>
                <li class="sub"><a class="wrap" data-scroll href="#controllerviewmodel">The ControllerViewModel</a></li>

                <li class="sub"><a data-scroll href="#initialisingdatacontexts">Initialising Data Contexts</a></li>
                <li class="sub"><a data-scroll href="#views">The UI and Views</a></li>
                <li class="sub"><a data-scroll href="#watchedstate">Watched State</a></li>
                <li class="sub"><a data-scroll href="#router">Working With The Router</a></li>
                <li class="sub"><a data-scroll href="#mediaquery">Media Query Notifications</a></li>
                <li class="sub"><a data-scroll href="#optimizingtheview">Optimizing the View</a></li>
                <li class="sub"><a data-scroll href="#animation">Animation</a></li>
                
                <li class="group-header"><a data-scroll href="#tips">Tips</a></li>
                <li class="sub"><a data-scroll href="#deleting">Deleting</a></li>
                <li class="sub"><a data-scroll href="#undoredo">Undo\Redo</a></li>
                <!-- <li class="sub"><a data-scroll href="#directives">Directives</a></li> -->

<!--                 <li class="sub"><a data-scroll href="#immutability">Immutability</a></li> -->
                <!-- The Application Data Context and how it works -> Properties etc.
                    Working with Models
                    Working with Arrays
                    Multiple Models
                    Undo/Redo Tips
                    watchedState Object
                    router object
                    MediaQuery
                    Animation
                 -->

                <!-- <li class="menu-item-divided pure-menu-selected">
                    <a href="#">Services</a>
                </li> -->
                <li class="group-header">
                    <a data-scroll href="#browser">Browser Support</a>
                </li>
            </ul>
        </div>
    </div>

    <div id="main">
        <div class="header">
            <h1>Astarisx Developer's Guide</h1>
        </div>

        <div class="content">
            
            <h2 class="content-subhead" id="concepts">Concepts</h2>
             <h3 class="content-subhead" id="mvvm">MVVM Pattern</h3>
            <p>
                Astarisx helps implement the Model-View-ViewModel pattern, which is a specialization of the <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> developed by Microsoft in 2005 to leverage WPF and Silverlight technologies. John Gossman, one of the Architects of WPF and Silverlight at Microsoft during that time, coined the term. <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">WPF Apps With The Model-View-ViewModel Design Pattern</a> by Josh Smith, explains the pattern and its history if you're interested. Another article I would recommend is Addy Osmani's <a href="http://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/">Understanding MVVM â€“ A Guide For JavaScript Developers</a>. He does a great job at explaining MVVM for the JavaScript developer.

                Anyway, what does this mean for Astarisx. Well, in a nut shell, the MVVM pattern allows you to write Business Logic that is completely sepearate from the View.

                A quote from WPF Apps With The Model-View-ViewModel Design Pattern summarizes MVVM nicely.
                </p>
                <blockquote>
                    <p>
                        ... a ViewModel does not need a reference to a view. The view binds to properties on a ViewModel, which, in turn, exposes data contained in model objects and other state specific to the view. The bindings between view and ViewModel are simple to construct because a ViewModel object is set as the DataContext of a view. If property values in the ViewModel change, those new values automatically propagate to the view via data binding. When the user clicks a button in the View, a command on the ViewModel executes to perform the requested action. The ViewModel, never the View, performs all modifications made to the model data. The view classes have no idea that the model classes exist, while the ViewModel and model are unaware of the view. In fact, the model is completely oblivious to the fact that the ViewModel and view exist. This is a very loosely coupled design, which pays dividends in many ways ...
                    </p>
                    <footer>
                        <cite><a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">Josh Smith</a></cite>
                    </footer>
                </blockquote>
                <p>
                In addition to the above.
                </p>
                <blockquote>
                    <p>... the [ViewModel] will observe the view and respond to events by changing any appropriate state and reloading the entire view.</p>
                    <footer>
                        <cite><a href="http://martinfowler.com/eaaDev/PresentationModel.html">Martin Fowler</a></cite>
                    </footer>
                </blockquote>
                <p>
                    So in the context of Astarisx, React components act as the View, "data binding" is one-way and a "command" on the ViewModel is simply referred to as an action.

                    Astarisx also includes a specialized ViewModel, referred to as the ControllerViewModel. The ControllerViewModel determines which ViewModels are exposed to the View.
                </p>
            <h3 class="content-subhead" id="anatomy">Application Anatomy</h3>
            <div class="pure-g">
                <div class="pure-u-1">
                    <img class="pure-img-responsive" src="../img/common/Astarisx.png" alt="Anatomy">
                </div>
            </div>
            <h4 class="content-subhead">Models</h4>
            <p>
                Yes, I know, you don't really need Models in React Applications. But these Models will really help simplify how your React application interacts with your data.

                So, for those unfamiliar with the concept, a Model is a abstraction of your application's data domain. What this means is that a Model represents a real entity, like a Person, Bank Account or Shopping Cart Item and it encapsulates the current state of that entity. Sometimes Models map nicely to a record/object in a data store, but more often then not, they don't. A Model can include domain logic, such as a save function or field validation and other Model specific logic.

                Astarisx Models are immutable. Meaning they can't be changed after they've been created. This ensures that the View, or any part of the application, doesn't go and change (mutate) an object they weren't supposed to potentially breaking your application and causing bugs.

                That's not to say that you can't change your data, you can. Astarisx makes it easy. You won't even know you're using immutable objects. Essentially, a Model's fields are exposed to the View and to update a Model you simply assign the new value to the field. For example to update a Person's name you would write something like <code class="wrap">this.state.appContext.people.currPerson.name = "Fred"</code>. This triggers the Application State to transition to a new state which includes your updated Model.

                A Model has no knowledge of the View or ViewModels. Whenever a Model changes state, a ViewModel is notified. It receives the model's new state and handles transitioning the model to the next state.
            </p>
            <h4 class="content-subhead">The ControllerViewModel</h4>
            <p>
                Every Astarisx application will have a ControllerViewModel. The ControllerViewModel is a specilialized ViewModel and is the entry point to your Astarisx application. It's responsibility is to manage and store Application State. This is where you define application level logic. The sort of things you might define in the ControllerViewModel may be application navigation, undo functionality or the application's online or busy status.

                The ControllerViewModel exposes ViewModels and all the methods and fields defined in the ControllerViewModel to the View. This is referred to as the Application Data Context.

                <!-- See ControllerViewModel -->
            </p>
            <h4 class="content-subhead">ViewModels</h4>
            <p>
                A ViewModel is where you define Business Logic and store View State. All methods and fields defined in a ViewModel are visible in the View via the ControllerViewModel. A ViewModel is also responsible for exposing Models, and consequently their methods and fields, to the View.

                It is common practice, when applying the Model-View-ViewModel pattern, to have a one to one relationship between a View and a ViewModel (i.e. one ViewModel represents a specific View's model, hence the name ViewModel). However, Astarisx doesn't require this. It is possible to have multiple Views share one or more ViewModels.

                The associated methods, fields and Models exposed by a ViewModel to the View, is referred to as a Data Context and forms part of the Application Data Context. A View interacts with a Data Context, invoking Actions, which are subsequently handled by the appropriate Model, ViewModel or ControllerViewModel resulting in a state transition.

                <!-- See ViewModels -->
            </p>
            <h4 class="content-subhead">The UI Container</h4>
            <p>
                React uses a single component to host all of the application's components. This component is at the apex of the component hierarchy. Astarisx refers to this component as the UI Container. The UI Container can hold regular React components and/or Astarisx Views. The UI Container receives a copy of the entire Application Data Context whenever there is a state change anywhere in the application.
            </p>
            <h4 class="content-subhead">Views</h4>
            <p>
                An Astarisx View is a self contained React component. They differ from regular React components in that they are stateless and completely decoupled from their Owner. Every View gets its own copy of the Application Data Context. Astarisx is capable of displaying multiple Views in the UI at any one time. These Views are also capable and most likely to contain any number of Views themselves.

                An Astarisx View is free to move around, within the application, without breaking functionality. It gets its own copy of the Application Data Context and receives a new copy whenever there is a state change within the application. State change notifications are sent to Mounted Views and can be easily configured for UI performance optimization, to only notify specific Views when specific state changes occur.

                <!-- See Views -->
            </p>
            <h4 class="content-subhead">State Manager</h4>
            <p>
                Astarisx takes on the responsibility of storing and managing the Application's State. Models, ViewModels and the ControllerViewModel store and manager their own state. The State Manager receives state change notifications from these objects, merges their state and transtions the application to the next state, the output being the Application Data Context. The Application Data Context is available to all Views and always holds the most current version of the Application's state. A View can interact with the Application Data Context, invoking Actions which are subsequently handled by the appropriate Model, ViewModel or the ControllerViewModel. The State Manager will then notify the Views of any state changes and pass them the latest Application Data Context. The State Manager is a system object. You don't need to create one of these.
                <!-- See Views -->
            </p>
           
            <h3 class="content-subhead" id="dataflow">Unidirectional Data Flow</h3>

            <div class="pure-g">
                <div class="pure-u-1">
                    <img class="pure-img-responsive" src="../img/common/unidata.png" alt="Unidirectional Data Flow">
                </div>
            </div>
            <p>Astarisx application data flows are unidirectional. A View will invoke an Action, usually via User interactions on the UI, which gets handled by a Data Context. Data, or state, then flows out to the State Manager. The State Manager merges this state with the current Application State, effectively transitioning the Application Data Context to the next state. It then notifies all Views that state has changed and sends them the new Application Data Context. The Views propagate any changes down through to its components.</p>

            <h2 class="content-subhead" id="guides">Guides</h2>
            <h3 class="content-subhead" id="gettingstarted">Getting Started</h3>

            <h4 class="content-subhead">Stand-alone </h4>
            <p>
            "Astarisx" is exposed as a global variable.
            <a href="https://github.com/entrendipity/astarisx/archive/master.zip">Download it.</a>
            </p>
            <pre><code><div class="code-block">&lt;script src="astarisx.min.js"&gt;&lt;/script&gt;</div></code></pre>


            <h4 class="content-subhead">Bower</h4>
            <pre><code><div class="code-block">$ bower install astarisx</div></code></pre>

            <h4 class="content-subhead">CommonJS</h4>
              <pre><code><div class="code-block">$ npm install astarisx</div></code></pre>

            <h4 class="content-subhead">AMD</h4>
<pre><code><div class="code-block">require(['./astarisx.min.js'], function(Astarisx){
  // Do something with Astarisx
});</div></code></pre>

<!-- Descriptors -->
            <h3 class="content-subhead" id="descriptors">Descriptors</h3>
            <p>Descriptors are used to define Model, ViewModel or ControllerViewModel behavior. Behaviors are able to be defined using descriptor functions or mixins, fields and methods.</p>
            
            <h4 class="content-subhead">Descriptor Functions</h4>
            <p><a href="./api.html#specs">Descriptor functions</a> are predefined Astarisx functions used to perform specific tasks or provide configuration information for your application. These functions are invoked by Astarisx during the life-cycle of an object. Each of the descriptor functions are explained in more detail in the relevant sections below.</p>
            
            <h4 class="content-subhead">Mixins</h4>
            <p>Mixins enable sharing and extending behavior amongst objects and are used much the same as you use them in React. </p>
            <p>An example of this is when multiple models use the same field (property). For example, the mixin below enables Models to have a <code>status</code> field.</p>

            <pre><code><div class="code-block">var modelMixin = {
  getInitialState: function(){
    return {
      status: this.status || ""
    };
  },
  status: {
    get: function(){
      return this.$state.status;
    }   
  }
}</div></code></pre>
    
            <p>To include the <code>status</code> field in a model, you simply "mixin" the code.</p>
<pre><code><div class="code-block">var Order = Astarisx.createModelClass({
  mixins: [modelMixin],
  getInitialState: function(){
    return {
      id: this.id|| uuid()
    };
  },

  id: {
    get: function(){
      return this.$state.id;
    }
  },
  ...
});
</div></code></pre>
            <p>As you can see this is quite straight forward, and you are still able to define a <code>getInitialState</code> in the target model. The two <code>getInitialState</code> functions will be called sequentially.</p>

    <h4 class="content-subhead">Fields</h4>
    <p>Fields are accessor descriptor objects, similar to that found in the <code><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a></code> method. They differ slightly in that the <code>enumerable</code> attribute is set to <code>true</code> by default, as opposed to <code>false</code>. <code>configurable</code> is <code>false</code> by default but cannot be overridden. The <code>enumerable</code> attribute however can be overridden, but it is not recommended as Astarisx relies on the ability to enumerate properties in order to transition state.</p>

    <p>To define a field you specify a key, which is the field name and then define a getter and/or setter.</p>
    <pre><code><div class="code-block">var Order = Astarisx.createModelClass({
    fldName: {
        get: function(){
            this.$state.fldName;
        },
        set: function(newValue){
            this.setState({fldName: newValue});
        }
    },
    ...
});</div></code></pre>
    <p>The <code>set</code> function takes one argument. To update a field value, you simply assign a value to it. There is no need to call <code>set</code> as the argument is automatically passed in. The value is then passed to the <code>setState</code> function which triggers a state transition. Once <code>setState</code> returns the object will have transitioned to the next state and <code>this.$state</code> will now hold the object's new state. <b>Fields are immutable. Never set a value of a field directly, as it will not persist, you must always use the <code>setState</code> function. This is particularly true within the Object that the field was defined in.</b></p>
    <p>When accessing a field there is no need to call <code>get</code>, you simply reference the field name. Although there are situations in which you may need to access a field value directly. In those situations you reference the field directly from the <code>$state</code> object. </p>
    <p>You can restrict access to a field by not defining a getter or setter, which would prevent the ability to access a field or set it's value respectively. This is just plain old javascript, no magic here.</p>
    
    <p>Fields defined as above are enumerable, which means that when persisting to a back end store, it will be visible to it and sent as part of the payload to the server. Sometimes you need a field that is only visible on the client. For instance, you may want to record whether a Model is in error with a field called <code>inError</code>. There is no need to send this to the server as it is purely for client side functionality. In these situations you can prefix the field name with an underscore. So <code>inError</code> would become <code>_inError</code>. This indicates to Astarisx that the field is a client-side field only, and is not to be sent to the server. You still update and access the field like a regular field but it will not persist to the server.</p>

    <p>Astarisx also includes some additional attributes. They are <code>viewModel</code>, <code>aliasFor</code>, <code>kind</code> and <code>validate</code>. These attributes modify how the field functions or extends it's funcitonality. More on field attributes can be found <a data-scroll href="#fieldattributes">here</a>.</p>
    <p><em>*See <a data-scroll href="#datacontextsandstate">Data Contexts and $state</a> for an explaination on the <code>$state</code> object.</em></p>


    <h4 class="content-subhead">Methods</h4>
    <p>A method is a function that performs a particular job. To create a method you simply define a javascript function and use it just like a regular javascript function.</p>

    <h3 class="content-subhead" id="fieldattributes">Field Attributes</h3>
    <p>When defining a field you are able to use Astarisx attributes to modify how the field behaves. Attributes may only be relevant in certain contexts. Below is an explaination on how to use them.</p>
    <h4 class="content-subhead">viewModel</h4>
    <p>The <code>viewModel</code> attribute is used to associate a dataContext to a viewModel. This attribute is only relevant within the ControllerViewModel.</p>
    <pre><code><div class="code-block">var CVM = Astarisx.createControllerViewModelClass({
    personCtx: {
        viewModel: personViewModel,
        get: function(){
            this.$state.personCtx;
        }
    },
    ...
});</div></code></pre>
    <p><code>personCtx</code> will be exposed to the View as "personCtx". Notice that we do not define a setter. Defining a setter has no effect, as the setter will be removed to avoid accidentally overriding the dataContext.</p>
    <h4 class="content-subhead">aliasFor</h4>
    <p>Sometimes the source data doesn't have the property names you would like to use in your application. <code>aliasFor</code> allows you to specify a field as the alias for a particular source property key. This attribute is only available in Models. If you wish to persist this field back to the source with the original name, you must convert it back manually, as Astarisx has no visability of this.<code></code></p>
    <pre><code><div class="code-block">var aModel = Astarisx.createModelClass({
    occupation: {
        aliaFor: 'job', //'job' is the key from the source
        get: function(){
            this.$state.occupation;
        },
        set: function(newValue){
            this.setState({occupation: newValue});
        }
    },
    ...
});</div></code></pre>
    <h4 class="content-subhead">validate</h4>
    <p><code>validate</code> accepts a <code>get</code> descriptor function that is used to validate the field. The getter must return a <code>Boolean</code>.</p>
    <pre><code><div class="code-block">var aModel = Astarisx.createModelClass({
    line1: {
        get: function(){
          return this.$state.line1;
        },
        set: function(newVal){
          this.setState({line1: newVal});
        },
        validate: {
          get: function(){
            return this.line1.length > 0;
          }
        }
    },
    ...
});</div></code></pre>
    <p>Specifying a <code>validate</code> attribute automagically creates two or more new properties on the Model's Data Context. For the above example, the fields created would be <code>$line1Valid</code>, which holds the return value of the validate attribute for the line1 field. Every field that specifies a validate attribute will have a corresponding property that holds the <code>validate</code> return value. Also created is the <code>$allValid</code> property. The <code>$allValid</code> property returns <code>true</code> if all of the Model's defined validations are <code>true</code>, otherwise it returns <code>false</code>.</p>
    


<!-- kind -->
    <h4 class="content-subhead">kind</h4>
    <p>The <code>kind</code> attribute modifies the behavior of a field. Below is a list of the values, with explainations, that can be assigned to <code>kind</code>.</p>

    <h5>uid</h5>
    <p>Stores a Modelâ€™s unique identifier. <strong>This is only available in Models and should only be specified once per Model definition.</strong></p>
    <h5>instance</h5>
    <p>This value indicates that the Object held within the specified field is a <code>Model</code> instance. This attribute needs to be specified when a <code>View</code> is going to interact with it. Fields with this attribute register <code>modelChangeHandler</code>s against the relevant ViewModel, so that the correct data context is updated. This is only available within ViewModels and Models.</p>
    <h5>array</h5>
    <p>Assign <code>kind:'array'</code> to all fields that hold arrays. This does a few things. It ensures that the array is initialized, it ensures that a setter has not been specified and that the array is immutable. Immutability does not extend to it's contents.</p>
    <h5>array:freeze</h5>
    <p><code>kind: 'array:freeze'</code> has the same affect as <code>kind:'array'</code> but the immutability extends to it's contents. However, immutability does not extend down any Object's hierarchy and is referred to as shallow immutability.</p>
    <h5>array:deepFreeze</h5>
    <p><code>kind: 'array:deepFreeze'</code> has the same affect as <code>kind:'array'</code> but the immutability extends to it's contents and down through any Object's hierarchy and is referred to as deep immutability. <em>Caution must be exercised when using this attribute value as this can be quite an expensive operation and cyclical references are not supported.</em></p>
    

    <h5>pseudo</h5>
    <p>A <code>kind: &quot;pseudo&quot;</code> field, does not hold its own value and will always reset its value to <code>undefined</code> during the next state transition. Use <code>kind: &quot;pseudo&quot;</code> when you need the field to reset itself to a default value or if the <code>field</code> gets itâ€™s value from another property. The two examples below may help clarify its usage:</p>
    <p><em>example 1: Reset value to a default</em></p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">didUpdate: {
  <span class="dt">kind</span>: <span class="st">&#39;pseudo&#39;</span>,
  <span class="dt">get</span>: <span class="kw">function</span>(){
    <span class="kw">return</span> <span class="kw">this</span>.<span class="ot">state</span>.<span class="fu">didUpdate</span> ? <span class="kw">this</span>.<span class="ot">state</span>.<span class="fu">didUpdate</span> : <span class="kw">false</span>;
  }
}</code></pre>
<p>When you set <code>didUpdate</code> to <code>true</code>, within a <code>setState</code> call, there is no need to set it back to <code>false</code>, as it will automatically be reset to <code>undefined</code> and re-evaluated in the <code>get</code>.</p>
<pre class="javscript"><code>//No need to set didUpdate back to false
this.setState({didUpdate: true});</code></pre>
<p><em>example 2: Value set by another property</em></p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">selectedHobby: {
  <span class="dt">kind</span>: <span class="st">&#39;pseudo&#39;</span>,
  <span class="dt">get</span>: <span class="kw">function</span>() {
    <span class="kw">return</span> <span class="kw">this</span>.<span class="ot">state</span>.<span class="ot">hobbiesContext</span>.<span class="fu">current</span> ?
      <span class="kw">this</span>.<span class="ot">state</span>.<span class="ot">hobbiesContext</span>.<span class="ot">current</span>.<span class="fu">name</span>: <span class="kw">void</span>(<span class="dv">0</span>);
  }
}</code></pre>
    <h5>static</h5>
    <p>Signifies that a field shouldnâ€™t change state when <code>revert()</code> or <code>advance()</code> is called and will persist itâ€™s state through state transitions unless <em>explicitly</em> updated. A good example would be a field that shows online status. If the online status changes, then you do not want undo functionality to reset it to the previous state, as this does not make sense. Another example is responding to Media Query Notifications. If screen orientation changes, then you do not care about the previous screen orientation and if <code>revert()</code> is called you want all the <code>state</code> to revert except the screen orientation. So if you had a field called <code>orientation</code> then you would set itâ€™s <code>kind</code> to <code>static</code>. <strong>This is only available in the ControllerViewModel.</strong></p>
    <h5>object</h5>
    <p>Indicates that the field holds a plain old javascript object. The object will be immutable, but it's objects and/or arrays it may hold are not.</p>
    <h5>object:freeze</h5>
    <p>Indicates that the field holds a plain old javascript object. The object and the first level in the object hierarchy will be immutable, but objects and/or arrays lower in the chain are not. (shallow immutability)</p>
    <h5>object:deepFreeze</h5>
    <p>Indicates that the field holds a plain old javascript object. The object and it's content will be immutable. (deep immutability). <em>Caution must be exercised when using this attribute value as this can be quite an expensive operation and cyclical references are not supported.</em></p>

    <h3 class="content-subhead" id="datacontextsandstate">Data Contexts and $state</h3>
    <h3 class="content-subhead" id="setstate">setState and Transitioning State</h3>
    <h3 class="content-subhead" id="models">Models</h3>
    <h3 class="content-subhead" id="viewmodels">ViewModels</h3>
    <h3 class="content-subhead" id="controllerviewmodel">The ControllerViewModel</h3>
    <h3 class="content-subhead" id="initialisingdatacontexts">Initializing Data Contexts</h3>
        <h4 class="content-subhead">getInitialState</h4>
        <p>This is called whenever the Object is created and enables the setting of inital state for the object. <code>getInitialState</code> works a little differently in Models then it does in ViewModels or the ControllerViewModel. See <a href="">Models</a> and <a href="">ViewModel</a> for an explaination on how it differs. Do not place ajax calls or process intensive code within this function, as it is called every time the object is created, which can be quite frequent.</p>

        <h4 class="content-subhead">dataContextWillInitialize</h4>
        <p>This is invoked after <code>getInitialState</code> in response to a call to <code><a href="./api.html#initializeappcontext">intializeAppContext</a></code> or <code><a href="./api.html#initializedatacontext">intializeDataContext</a></code>. <code>dataContextWillInitialize</code> is only called once during the life of your application. From within this function you have access to the initialized state and the opportunity to invoke ajax calls to get data from external sources.</p>
        <p>The reason you should not include ajax calls in <code>getInitialState</code> is that it is called every time the object is created, which can be quite frequent.</p>
        <p>To use <code>dataContextWillInitialize</code> define what it needs to do within your ViewModel. Then call <code>intializeAppContext</code> or <code>intializeDataContext</code> from within your application, which will invoke <code>dataContextWillInitialize</code>.</p>
        
    <h3 class="content-subhead" id="views">The UI and Views</h3>
    <h3 class="content-subhead" id="watchedstate">Watched State</h3>
    <h3 class="content-subhead" id="router">Working with the Router</h3>
    <h3 class="content-subhead" id="mediaquery">Media Query Notifications</h3>
    <h3 class="content-subhead" id="optimizingtheview">Optimizing the View</h3>
    <h3 class="content-subhead" id="animation">Animation</h3>



            <h2 class="content-subhead" id="browser"><a>Browser Support</a></h2>
            <p>Most ECMAScript 5 compliant browsers.</p>

            <p><b>IE8 and below is not supported.</b></p>

            <p><b>IE9 and below is not supported if the pushState option is enabled.</b></p>
            
        </div>
    </div>
</div>



<script src="../lib/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="js/ui.js"></script>
<script src="../lib/smooth-scroll.js"></script>
<script>
    smoothScroll.init({
      speed: 1000, // Integer. How fast to complete the scroll in milliseconds
    easing: 'easeInOutCubic', // Easing pattern to use
    // updateURL: false, // Boolean. Whether or not to update the URL with the anchor hash on scroll
    // offset: 80, // Integer. How far to offset the scrolling anchor location in pixels
    // callbackBefore: function ( toggle, anchor ) {}, // Function to run before scrolling
    // callbackAfter: function ( toggle, anchor ) {} // Function to run after scrolling
    });
</script>


</body>
</html>
