<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Astarisx Documentation</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow-night-bright.min.css">
  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
    <!--<![endif]-->

</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>

    <div id="menu">
        <div class="pure-menu pure-menu-open">
            
            <a class="pure-menu-heading" href="../index.html"><span class="fa fa-arrow-left"></span>Astarisx</a>

            <ul>
                <li class="group-header"><a data-scroll href="#tutorial">Building a Simple CRM</a></li>
                <li class="sub"><a data-scroll href="#projectsetup">Project Setup</a></li>
                <li class="sub"><a data-scroll href="#applicationstructure">Application Structure</a></li>
                <li class="group-header"><a data-scroll href="#basic">Basic Application</a></li>
                <li class="sub"><a data-scroll href="#creatingthemodels">Creating the Models</a></li>
                <li class="sub"><a data-scroll href="#creatingaviewmodel">Creating a ViewModel</a></li>
                <li class="sub"><a data-scroll href="#constructingmodels">Constructing Models</a></li>
                <li class="sub"><a data-scroll href="#exposingadatacontext">Exposing a Data Context</a></li>
                <li class="sub"><a data-scroll href="#buildingtheui">Building the UI</a></li>
                <li class="sub"><a data-scroll href="#updatingmodeldata">Updating Model Data</a></li>
                <li class="sub"><a data-scroll href="#addingmodels">Adding Models</a></li>
                <li class="sub"><a data-scroll href="#deletingmodels">Deleting Models</a></li>
                <li class="sub"><a data-scroll href="#enableundo">Enable Undo</a></li>
                <li class="sub"><a data-scroll href="#movingstuffaround">Moving Stuff Around</a></li>
                
                <li class="group-header"><a data-scroll href="#enhancingtheapplication">Enhancing the Application</a></li>
                <li class="sub"><a data-scroll href="#stilltocome">Adding Application State</a></li>
                <li class="sub"><a data-scroll href="#stilltocome">pushState Routing</a></li>
                <li class="sub"><a data-scroll href="#stilltocome">MediaQuery Notifications</a></li>
                <li class="sub"><a data-scroll href="#stilltocome">Optimizing the View</a></li>
                <li class="sub"><a data-scroll href="#stilltocome">Adding Transition Animations</a></li>
                <!-- <li class="group-header"><a data-scroll href="#tips">Tips</a></li>
                <li class="group-header"><a data-scroll href="#videos">Videos</a></li>
                <li class="group-header"><a data-scroll href="#resources">Resources</a></li> -->
            </ul>
        </div>
    </div>

    <div id="main">
        <div class="header">
            <h1>Astarisx Tutorial</h1>
            <h2>Work in progress</h2>
        </div>

        <div class="content">
            <h2 class="content-subhead" id="tutorial">Building a Simple CRM</h2>
            <p>We are going to be build a simple CRM application. The application is a little contrived but will serve to demonstrate most of the concepts within Astarisx. We"ll start by building a basic version and add functionality as we go until we have a our completed CRM. If you would like to follow along with this tutorial, you need <a href="http://nodejs.org/">Node.js</a> and <a href="http://gulpjs.com/">gulp</a> installed. It is assumed that you are familar with <a href="http://facebook.github.io/react/">React</a>.</p>
            
            <p>The application should end up looking something like this.</p>
            <img class="pure-img" src="../img/ScreenShot_Example.png">
            <p>The source code of the completed application for this tutorial can be found on <a href="">GitHub (To be set)</a></p>
            

            <h3 class="content-subhead" id="projectsetup">Project Setup</h3>
            <p>After ensuring you have Node and gulp installed, run the following command in a terminal.</p>
            <pre><code><div class="code-block">git clone https://github.com/entrendipity/astarisx-starterkit.git</div></code></pre>
            <p>This will create a directory called <code>astarisx-starterkit</code> which will give us a basic project structure to work with. <em>If you don"t have <a href="http://git-scm.com/">git</a> installed, you can <a href="https://github.com/entrendipity/astarisx-starterkit/archive/master.zip">download the starter kit from here</a> and extract it into a directory.</em></p>

            <p>Before we go any further we should take a look at what the starter kit has given us.</p>
            <p>The starter kit gives us a basic project structure and some tools to develop our app. In the root directory we have a <code>gulpfile.js</code> used to configure gulp tasks, a package.json and README.md files, nothing that you need to worry about for what we are doing, and an <code>index.html</code>, main.js and app directory. The last the things are what we care about. Let"s take a look.</p>
            <p>The <code>index.html</code> file, although relevant, is nothing special. If you"ve written a React application you will now that the <code>index.html</code> file is just the container that holds your application. So let"s move onto to <code>main.js</code></p>
            <pre><code><div class="code-block">/* main.js */
var React = require("react"),
  App = require("./app/view/ui");

module.exports = React.render(&lt;App /&gt;, document.body);</div></code></pre>
<p>Again nothing really to see here, we are simply initializing the application as per normal.</p>
<p>The <code>app</code> directory is a little more interesting. It is made up of three directories, <code>models</code>, <code>view</code> and <code>viewModels</code>. This is where the code for our application will be stored. The <code>models</code> directory has a <code>models.txt</code> file in it, acting as a place holder and it can be deleted. We"ll put our models in here later. The <code>viewModels</code> directory has a file called <code>cvm.js</code> this is the most basic ControllerViewModel that you can create. We need a reference to the ControllerViewModel from the View. So in the <code>view</code> directory we have a file called <code>ui.js</code>, this is the file that was referenced in <code>main.js</code> and is what Astarisx refers to as the UI Container, as it will hold all the other components. Let"s crack it open.</p>
<pre><code><div class="code-block">/* ui.js */
var React = require("react");
var Astarisx = require("astarisx");
var cvm = require("../viewModels/cvm");

var UI = React.createClass({
  mixins: [Astarisx.mixin.ui],
  componentWillMount: function(){
    this.initializeAppContext({ 
      controllerViewModel: cvm
    });
  },

  render: function(){
    return (&lt;h1&gt;All OK!&lt;/h1&gt;);
  }
});
module.exports = UI;</div></code></pre>

    <p>This is where we are reference the ControllerViewModel (i.e. <code class="wrap">var cvm = require("../viewModels/cvm")</code>. It is passed into the <code>initializeAppContext</code>, within the <code>componentWillMount</code>, and will initialize the Application Data Context. An important thing to note, is that we mixin <code class="wrap">Astarisx.mixin.ui</code>. This turns the React component into an Astarisx UI Container. It will attach a special property called <code>appContext</code> to the component"s state object. We will be referencing <code>appContext</code> alot.</p>

    <p>Now rename the <code>astarisx-starterkit</code> directory to <code>astarisx-tutorial</code>. Navigate into the <code>astarisx-tutorial</code> and run <code>npm install</code>.</p>
            <pre><code><div class="code-block">npm install</div></code></pre>
            <p>This will download and install the required components to build your app. You will notice that a <code>node_modules</code> directory was created. This is where our modules live. Once that is done, run the following command.</p>
            <pre><code><div class="code-block">gulp serve</div></code></pre>
            <p>This will start a local http server and (hopefully) open a web browser displaying the application. It should have also created two new root directories called <code>build</code> and <code>assets</code>. This is where our compiled files land for our application. Keep the terminal window open and the browser should automatically update as we make changes.</p>

            <h3 class="content-subhead" id="applicationstructure">Application Structure</h3>
            <p>Our application is going to have the following Astarisx object:
                <ul>
                    <li>Person Model</li>
                    <li>Hobby Model</li>
                    <li>Persons ViewModel</li>
                    <li>persons Data Context</li>
                </ul>
                We'll be using the following demo data.
                <pre><code><div class="code-block">/* Demo Data */
[{
    "id": "1",
    "firstName": "Frank",
    "lastName": "Smith",
    "gender": "male",
    "dob": "1980-03-03",
    "job": "Dentist",
    "hobbies": [{"id": "1", "hobby": "reading"},
        {"id": "2", "hobby": "golfing"},
        {"id": "3", "hobby": "cutting code"}]
},{
    "id":"2",
    "firstName": "Lisa",
    "lastName": "Jones",
    "gender": "female",
    "dob": "1985-02-22",
    "job": "Accountant",
    "hobbies": [{"id": "1", "hobby": "reading"}]
},{
    "id": "3",
    "firstName": "John",
    "lastName": "Citizen",
    "gender": "male",
    "dob": "1975-12-11",
    "job": "Unemployed",
    "hobbies": [{"id": "1", "hobby": "watching YouTube"}]
}]</div></code></pre>

            </p>
            <p>OK, let"s get started.</p>
            <h2 class="content-subhead" id="basic">Basic Application</h2>

            
            
            <h3 class="content-subhead" id="creatingthemodels">Creating the Models</h3>
            <p>In the <code>models</code> directory create a file called <code>person.js</code> and add the following code.
            <pre><code><div class="code-block">/* models/person.js */
var Astarisx = require('astarisx');

var person = Astarisx.createModelClass({

  id: {
    get: function(){
      return this.$state.id;
    }
  },
  
  firstName: {
    get: function(){ 
      return this.$state.firstName; 
    },
    set: function(newValue){
      this.setState({firstname: newValue});
    }
  },

  lastName: {
    get: function(){ 
      return this.$state.lastName; 
    },
    set: function(newValue){
      this.setState({lastName: newValue});
    }
  },

  job: {
    get: function(){
      return this.$state.job;
    },
    set: function(newValue){
      this.setState({'job': newValue});
    }
  },

  dob: {
    get: function(){
      return this.$state.dob;
    },
    set: function(newValue){
      this.setState({'dob': newValue});
    }
  },

  gender: {
    get: function(){ 
      return this.$state.gender; 
    },
    set: function(newValue){
      this.setState({'gender': newValue});
    }
  },

  hobbies: {
    kind: 'array',
    get: function(){
      return this.$state.hobbies;
    }
  }

});

module.exports = person;</div></code></pre>
            We create a field with the same name for each of the fields in the source object. Apart from the <code>id</code> and <code>hobbies</code> fields, each field has a getter and setter. The getter returns whatever is stored in the <code>$state</code> object. The setter sets the value of the field using <code>setState</code> which triggers a state transition. The new value will be stored in <code>$state</code> once the state transition has completed. The reason that <code>id</code> does not have a setter is that we want to prevent anything from changing it's state. <code>hobbies</code> is an array, so we specify the <code>kind</code> attribute with the value array. Astarisx needs to know which fields are arrays becuase they require some extra attention. You don't need to worry about that, Astarisx takes care of it for you. It doesn't need a setter because all updates to arrays are done via method calls.</p>
            <p>We don't have to define a field for every key in our source data. If we decided not to the value would not be lost, it would simply form part of the object's state (i.e. <code>this.$state</code>). 
            </p>
            <p>Before we move on, we need to add two additional fields to our Person Model. A <code>fullName</code> field, which will display the person's full name and an <code>age</code> field, which is a calculated field based on the <code>dob</code> (data of bith) field. below is the code for the <code>fullName</code> field.
            <pre><code><div class="code-block">fullName: {
  kind: 'pseudo',
  get: function(){
    if(this.lastName === void(0)){
      return this.firstName;
    }
    return this.firstName + ' ' + this.lastName;
  },
  set: function(newValue){
    var nextState = {};
    var nameArr = newValue.split(' ');
    var isSpace = newValue.slice(-1)[0] === ' ';
    var firstname = nameArr[0];
    var lastname = nameArr.slice(1).join(' ');

    nextState.firstName = firstname.length === 0 ? void(0) : firstname;
    nextState.lastName = lastname.length === 0 && !isSpace ? void(0) : lastname;

    this.setState(nextState);
  }
}</div></code></pre>
The <code>fullName</code> field derives it's value from <code>firstName</code> and <code>lastName</code> and for this reason we use the <code>kind</code> attribute with a value of <code>pseudo</code>.  A pseudo field is a field that does not retain it's value, so it must get it's value from some other source. The getter concatenates <code>firstName</code> and <code>secondName</code> and returns the result. Whilst the setter analyzes the <code>newValue</code> and updates <code>firstName</code> and/or <code>lastName</code>.</p>
<p>Pseudo fields are also useful for calculated fields. The <code>age</code> field is a calculated field based on the <code>dob</code> field and it's code is below.
<pre><code><div class="code-block">age: {
  kind: 'pseudo',
  get: function(){
    if(this.dob === void(0) || this.dob.length < 10){
      return 'Enter your Birthday';
    }
    var DOB = new Date(this.dob);
    var ageDate = new Date(Date.now() - DOB.getTime());
    var age = Math.abs(ageDate.getFullYear() - 1970);
    return isNaN(age) ? 'Enter your Birthday' : age + ' years old';
  }
}</div></code></pre></p>
    




    <p>We also need to update the <code>job</code> field. We would prefer that the <code>job</code> field was called <code>occupation</code>. To transform <code>job</code> to <code>occupation</code> we use the <code>aliasFor</code> attribute. The job field should now look like this.
            <pre><code><div class="code-block">occupation: {
  aliasFor: 'job',
  get: function(){
    return this.$state.occupation;
  },
  set: function(newValue){
    this.setState({'occupation': newValue });
  }
}</div></code></pre>
Whenever a Person model is referenced, you will use <code>occupation</code> like a regular model field, instead of <code>job</code>. When you persist this model back to the data store, Astarisx sends the <code>occupation</code> field as "occupation". If this is not what you would like, then you need to transform <code>occupation</code> back to <code>job</code> before it is sent to the server. Astarisx provides a convenience method called <code>transpose</code>, which replaces model fields with whatever name you like. Another approasch to transforming fileds is to use the <code>kind</code> attribute with a value of <code>pseudo</code>. We will use this approach in the Hobby model below.
            </p>


  




  <p>Next we create the <code>hobby</code> model.
            <pre><code><div class="code-block">/* models/hobby.js */
var Astarisx = require('astarisx');

var hobby = Astarisx.createMClass({

  id: {
    get: function(){
      return this.$state.id;
    }
  },

  hobby: {
    get: function(){
      return this.$state.hobby;
    },
    set: function(newValue){
      this.setState({'hobby': newValue });
    }
  }
});

module.exports = hobby;</div></code></pre>
The Hobby model has two fields, <code>id</code> and <code>hobby</code>. We would like to reference the <code>hobby</code> as <code>name</code> in the View, but when it gets saved to the data store we still want it to be stored as <code>hobby</code>. We can define a pseudo field to accomplish this. A pseudo field is a field that does not retain it's value. It must get it's value from some other source. In this instance we are going to use <code class="wrap">this.$state.hobby</code> as the source for the pseudo field <code>name</code>. Pseudo fields are non-enumerable and are not stored in an object's <code>$state</code> object, so won't form part of the payload when being sent to the server.
<pre><code><div class="code-block">name: {
  kind: 'pseudo',
  get: function(){
    return this.$state.hobby;
  },
  set: function(newValue){
    this.setState({'hobby': newValue });
  }
}</div></code></pre>
 Add another field called <code>name</code> ensuring to include the <code>kind</code> attribute with a value of <code>pseudo</code>. Notice that the pseudo field <code>name</code> gets it's value from <code class="wrap">this.$state.hobby</code> and will set the <code>hobby</code> field. We still need the <code>hobby</code> field available for this to work. So the View will see both <code>hobby</code> and <code>name</code>, but the server will only see <code>hobby</code>. If you like you can remove the setter from the <code>hobby</code> field and this will still work, however all updates will need to be done via the <code>name</code> field.</p>
            
            <h3 class="content-subhead" id="creatingaviewmodel">Creating a ViewModel</h3>
            <p>Now let's create a ViewModel that will reference the models created above. Create a file called <code>persons.js</code> in the <code>viewModels</code> directory. This file will hold the personsViewModel, which will store a collection of <code>person</code> model objects.
            <pre><code><div class="code-block">var Astarisx = require('astarisx');
var personsViewModel = Astarisx.createViewModelClass({
});
module.exports = personsViewModel;</div></code></pre>
The above code creates an empty ViewModel. We need to fill it will <code>person</code> models. But first we should reference this module in the ControllerViewModel. Place the code below somewhere at the top of <code>cvm.js</code>.
<pre><code><div class="code-block">var PersonViewModel = require('./persons');</div></code></pre>
Requiring our PersonViewModel module let's gulp know that it needs to watch the <code>persons.js</code>. It will now be parsed and compiled and the browser will update whenever we make a change to it. </p>



<h3 class="content-subhead" id="constructingmodels">Constructing Models</h3>
<p>So back to the ViewModel. Create a reference to your model by requiring <code>person.js</code>.
            <pre><code><div class="code-block">var Astarisx = require('astarisx');
var personCtor = require('../models/person');

var personsViewModel = Astarisx.createViewModelClass({
});
module.exports = personsViewModel;</div></code></pre>
We store the model reference in a variable called <code>personCtor</code>, you could call it anything you like, but why have I referred to it as <code>personCtor</code>. Astarisx objects actually return object constructors. Astarisx automatically instantiates ViewModels and the ControllerViewModel for you, so you never have to worry about them. Models are not automatically instantiated. The reason is that models need additional information. We use the Model constructor to create a function that we then use to instantiate a model at runtime, so we need to add a little boiler plate code. It looks like this
<pre><code><div class="code-block">var Person = function(){
    return new personCtor().apply(this, arguments);
};</div></code></pre>
This code sits outside of the ViewModel descriptor, like so...
            <pre><code><div class="code-block">var Astarisx = require('astarisx');
var personCtor = require('../models/person');

var Person = function(){
    return new personCtor().apply(this, arguments);
};

var personsViewModel = Astarisx.createViewModelClass({
});

module.exports = personsViewModel;</div></code></pre>
The <code>Person</code> function allows us to instantiate a <code>Person</code> model by calling <code>new Person()</code> from within the ViewModel descriptor. However, the <code>personCtor</code> takes an optional argument, which is a <code>modelChangeHandler</code>. This is the piece that the model needs at runtime. We are going to call it <code>personChangeHandler</code>. Let's create it now.
<pre><code><div class="code-block">var Astarisx = require('astarisx');

var personCtor = require('../models/person');

var personChangeHandler = function(nextState, nextAppState, callback){
    
};

var Person = function(){
    return new personCtor(personChangeHandler).apply(this, arguments);
};

var personsViewModel = Astarisx.createViewModelClass({
});

module.exports = personsViewModel;</div></code></pre>
We will add some code to the <code>personChangeHandler</code> later, but for now we just pass it into <code>personCtor</code>. What this does is associates <code>personChangeHandler</code> with the ViewModel's data context at the time it is instantiated. So everytime <code>new Person()</code> is called we grab the <code>personChangeHandler</code> with the current data context. It's not important to fully understand this concept at this point, it will become apparent as to what all this means as you use Astarisx, .
</p>
<p>We will need to a Hobby model to the Person Model, as hobby is an array of objects in the source object. So add the following code to the top of<code>person.js</code> model.
<pre><code><div class="code-block">var hobbyCtor = require('./hobby');

var Hobby = function(){
    return new hobbyCtor().apply(this, arguments);
};</div></code></pre>
Then within the <code>person</code> descriptor add a <code>getInitialState</code> that will be used to create the Hobby models whenever a Person model is instantiated.
<pre><code><div class="code-block">getInitialState: function(){
  var hobbies = this.$state.hobbies || [];
  var arr = hobbies.map(function(hobby){
    return new Hobby(hobby);
  });
  return {
    id: this.id || Date.now(),
    hobbies: arr 
  };
}</div></code></pre>
When you create a Person object, you pass in the current state, that current state includes the 'hobbies' array, which we reference using <code class="wrap">this.$state.hobbies</code>. We iterate over that array and for each item, we instantiate a Hobby obect and store it in an array called <code>arr</code>. We then return an object that specifies that the <code>hobbies</code> field is to be initialized with the <code>arr</code> array. The <code>hobbies</code> field is an Astarisx array that now holds Astarisx model objects.</p>
<p>OK, let's start populating our personsViewModel with some data. In the root project directory, create a directory called <code>data</code>. Within that directory create a file and cut and paste the demo data above into that file and save it as <code>demo.js</code>. This will act as our source data.</p>

<p>Then back in the <code>personsViewModel</code> descriptor create a field called <code>collection</code>. This is where we are going to store the person model instances. 
<pre><code><div class="code-block">collection: {
  kind: 'array',
  get: function(){ return this.$state.collection; },
}
</div></code></pre>
<code>collection</code> is an Array, so we assign a <code>kind</code> attribute with a value of <code>array</code>. We also define <code>dataContextWillInitialize</code>.
<pre><code><div class="code-block">dataContextWillInitialize: function(){
  var self = this;
  var xhr = new XMLHttpRequest();
  xhr.open('GET', './data/demo.json', true);
  xhr.onload = function(e) {
    if (this.status == 200) {
      var persons = JSON.parse(this.response);
      if(!!persons){
        var personsCollection = persons.map(function(person){
          return new Person(person);
        });
        self.setState({
          collection: personsCollection
        });
      }
    }
  };
  xhr.send();
}</div></code></pre>
<code>dataContextWillInitialize</code> is where you make ajax calls and initialize data for the ViewModel. You do not make ajax calls in <code>getInitialState</code>. Once the server returns with our data, we populate <code>personsCollection</code> with new model instances, then call <code>setState</code> to transition the <code>personsViewModel</code> to the next state with <code>collection</code> holding the new models.
</p>


<h3 class="content-subhead" id="exposingadatacontext">Exposing a Data Context</h3>

<p>Switch over to the ControllerViewModel. We are going to setup and intialize the <code>persons</code> data context. The data context is what will be exposed to the View, once defined in the ControllerViewModel, the View will have visibility of it and will be able to access it's fields and mthods.</p>

<p> Within the <code>cvm.js</code> file add a <code>dataContextWillInitialize</code> function to the ControllerViewModel descriptor. Within that function initialize all data contexts by calling <code class="wrap">this.initializeDataContext('*');</code>. Of course this has no affect because we haven't defined a data context as yet. So let's do that. Add the following code to the descriptor.

<pre><code><div class="code-block">persons: {
    viewModel: personsViewModel,
    get: function(){
      return this.$state.persons;
    }
}</div></code></pre>
We create a field with the name <code>persons</code>. <code>persons</code> will be the name of the data context and what the View will see. We add a special attribute, called <code>viewModel</code>, to the field. This allows us to associate a ViewModel to the data context. We pass it a reference to our <code>personsViewModel</code>. Your ControllerViewModel should now look like this.

<pre><code><div class="code-block">var Astarisx = require('astarisx');
var personsViewModel = require('./persons');

var controllerViewModel = Astarisx.createCVMClass({
  dataContextWillInitialize: function(){
    this.initializeDataContext('*');
  },
  persons: {
    viewModel: personsViewModel,
    get: function(){
      return this.$state.persons;
    }
  }
});

module.exports = controllerViewModel;</div></code></pre>
When you run your application the ControllerViewModel's <code>dataContextWillInitialize</code> will be called invoking <code>intializeDataContext</code> which will call the <code>personsViewModel</code>'s <code>dataContextWillInitialize</code> which will call <code>setState</code> and populate the collection by transitioning to the next state. So your collection should have 3 person models in it.</p>

<b><em>Because we haven't set up the View to display data as yet, you can't see anything. What I like to do is place this
<pre><code><div class="code-block">console.log('Application State --> ', this.state.appContext);</div></code></pre> at the top of the <code>render</code> function in <code>ui.js</code>, then open the browser's javascript console and inspect the object. The object will have a key called 'persons', this is the data context that we exposed to the View from the ControllerViewModel.</em></b>

</p>

    <h3 class="content-subhead" id="buildingtheui">Building the UI</h3>
    <p>It is assumed that you understand how to build React components, so discussions on how to build React components or React features are glossed over.</p>
    <p>The first thing we need to do is reference Twitter's <a href="http://getbootstrap.com/">Bootstrap</a> library so that we can use the grid and css. Add this to your index.html head.
    <pre><code><div class="code-block">&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css"&gt;</div></code></pre>
    </p>
    <p>
    The UI is comprised of the following components.
    <ul>
        <li>UI (ui.js) - Astarisx UI Container</li>
        <li>MenuBar (menuBar.js)</li>
        <li>Navigation (navigation.js) - Person selector</li>
        <li>Details (details.js) - displays details and hobbies of a selected Person</li>
        <li>PersonForm (personForm.js) - displays details of a selected Person</li>
        <li>PersonList (personList.js) - The List of People</li>
        <li>PersonListItem (PersonListItem.js)</li>
        <li>HobbyList (hobbyList.js) - List of Person's hobbies</li>
        <li>HobbyListItem (hobbyListItem.js)</li>
    </ul>
    Let's revisit <code>ui.js</code>. This is the component that will hold all of the application's components. We have already mixed in <code class="wrap">Astarisx.mixin.ui</code> and placed initialization code and  referenced our ControllerViewModel within the <code>componentWillMount</code> function. So we can start creating our Astarisx View components.
    </p>
    <p>The first component we are going to create is the MenuBar. Create a file called <code>menuBar.js</code> in the <code>views</code> directory and add the following code and save it.
    <pre><code><div class="code-block">var React = require('react');

var Component = React.createClass({

  displayName: 'MenuBar',
  render: function(){
    return (
      &lt;nav className="navbar navbar-default" role="navigation"&gt;
        &lt;div className="container-fluid"&gt;
          &lt;div className="navbar-header"&gt;
            &lt;button type="button"
            className="navbar-toggle"
            data-toggle="collapse"
            data-target="#bs-example-navbar-collapse-1"&gt;
              &lt;span className="sr-only"&gt;Toggle navigation&lt;/span&gt;
              &lt;span className="icon-bar"&gt;&lt;/span&gt;
              &lt;span className="icon-bar"&gt;&lt;/span&gt;
              &lt;span className="icon-bar"&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;a className="navbar-brand" href="#"&gt;
              Astarisx CRM
            &lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/nav&gt;
    );
  }
});

module.exports = Component;</div></code></pre>
Go over to <code>ui.js</code> and add the <code>menuBar</code> component.
<pre><code><div class="code-block">var React = require('react');
var Astarisx = require('astarisx');
var cvm = require('../viewModels/cvm');

var MenuBar = require('./menuBar');

var UI = React.createClass({
  mixins: [Astarisx.mixin.ui],
  componentWillMount: function(){
    this.initializeAppContext({ 
      controllerViewModel: cvm
    });
  },

  render: function(){
    console.log('Application State --> ', this.state.appContext);
    return (&lt;div&gt;
      &lt;MenuBar /&gt;
    &lt;/div&gt;);
  }
});
module.exports = UI;</div></code></pre>
A Menu Bar should appear at the top of the page.</p>
<p>Quickly create the other component files in the <code>views</code> directory and place the following code in each of them, ensuring that you replace the <code>displayName</code> property with the name of the component.
<pre><code><div class="code-block">var React = require('react');

var Component = React.createClass({

  displayName: 'MenuBar',
  render: function(){

    return (
      &lt;div&gt;Placeholder&lt;/div&gt;
    );
  }
});

module.exports = Component;</div></code></pre>
We will add to this code as we go. But for now open <code>ui.js</code> and add the Navigation and Details components. Your UI component should look something like this:
<pre><code><div class="code-block">var React = require('react');
var Astarisx = require('astarisx');
var cvm = require('../viewModels/cvm');

var MenuBar = require('./menuBar');
var Nav = require('./navigation');
var Details = require('./details');

var UI = React.createClass({
  mixins: [Astarisx.mixin.ui],
  componentWillMount: function(){
    this.initializeAppContext({ 
      controllerViewModel: cvm
    });
  },

  render: function(){
    console.log('Application State --> ', this.state.appContext);
    return (&lt;div&gt;
      &lt;MenuBar /&gt;
      &lt;div className="container"&gt;
        &lt;div className="row"&gt;
          &lt;div className="col-md-4"&gt;
            &lt;Nav /&gt;
          &lt;/div&gt;
          &lt;div className="col-md-8"&gt;
            &lt;Details /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div>);
  }
});
module.exports = UI;</div></code></pre>
Let's start adding some code to the Navigation component. The Navigation component will comprise a list of people, that we can click on that will help us navigate between people, and it will also have an input, that will allow us to add new people. Let's add the list first. Open <code>navigation.js</code> add a reference to the PersonList component called <code>PersonList</code> and update the render function with the following code.
<pre><code><div class="code-block">render: function(){
  return (
    &lt;div&gt;&lt;PersonList /&gt;&lt;/div&gt;
  );
}</div></code></pre>
That's it for now, we'll come back and add the input field later. Let's open <code>personListItem.js</code> and replace the render function with the code below.
<pre><code><div class="code-block">render: function() {
  var person = this.props.person;
  return (
    &lt;a className="list-group-item"
      href="#"&gt;{person.fullName}
      &lt;span className="glyphicon glyphicon-trash pull-right"&gt;&lt;/span&gt;
    &lt;/a&gt;
  );
}</div></code></pre>
Now open <code>personList.js</code> and reference Astarisx and the PersonListItem component and add the following code
<pre><code><div class="code-block">mixins: [Astarisx.mixin.view],
render: function() {
  var persons = this.state.appContext.persons;
  var collection = persons.collection;
  var list = collection.map(function(person){
    return (
      &lt;PersonListItem
        key={person.id}
        person={person} /&gt;
    );
  });
  return (
    &lt;div className="list-group"&gt;
      {list}
    &lt;/div&gt;
  );
}</div></code></pre>
Let's take a moment and look at what's going on here. Within the PersonList component we reference Astarisx and mix in <code class="wrap">Astarisx.mixin.view</code>. The transforms PersonList from a regular React component into an Astarisx View. The PersonList component has become <b>a fully self contained component.</b> It does not require state to be passed via props, as all the state is held within the <code>appContext</code> object, which was appended to the component's state object when <code class="wrap">Astarisx.mixin.view</code> was mixed in. <code>appContext</code> has a reference to the <code>persons</code> data context that was exposed through the ControllerViewModel It will always hold the most current state and is the <b>Single Source of Truth</b> for your application's data.</p>
<p>So within the render function we are able to access the entire Application's Data Context. For now, we're only interested in the <code>persons</code> data context, so we get a reference to it and iterate over the collection to populate our list.</p>
<p>Let's update the Details component. The Details component, will display a form with a person's information and a list of hobbies using the Hobby List component. First we'll add the PersonForm.</p>
<p>Open <code>details.js</code> and reference Astarisx, then mixin in the view as you did for the PersonList then replace the render function with the code below.
<pre><code><div class="code-block">render: function() {
  var persons = this.state.appContext.persons;
  var current = persons.selectedPerson;

  var display;
  if(!current){
    display = &lt;div&gt;Select or add a person&lt;/div&gt;;
  } else {
    display = (
      &lt;div&gt;
        &lt;form className="form-horizontal" role="form"&gt;
          &lt;div className="form-group"&gt;
              &lt;label className="col-md-2 control-label"&gt;Name&lt;/label&gt;
              &lt;div className="col-md-3"&gt;
                &lt;input className="form-control" type="text" 
                  value={current.fullName} /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div className="form-group"&gt;
              &lt;label className="col-md-2 control-label"&gt;Occupation&lt;/label&gt;
              &lt;div className="col-md-3"&gt;
                &lt;input className="form-control" type="text"
                  value={current.occupation} /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div className="form-group"&gt;
              &lt;label className="col-md-2 control-label"&gt;Gender&lt;/label&gt;
              &lt;div className="col-md-3"&gt;
                &lt;div className="radio"&gt;
                &lt;label&gt;
                  &lt;input type="radio" 
                    value="male"
                    checked={current.gender === 'male'} /&gt;
                  Male
                &lt;/label&gt;
              &lt;/div&gt;
              &lt;div className="radio"&gt;
                &lt;label&gt;
                  &lt;input type="radio"
                    value="female"
                    checked={current.gender === 'female'} /&gt;
                  Female
                &lt;/label&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div className="form-group"&gt;
              &lt;label className="col-md-2 control-label"&gt;Birthday&lt;/label&gt;
              &lt;div className="col-md-3"&gt;
                &lt;input className="form-control" type="text"
                placeholder="yyyy-mm-dd"
                value={current.dob} /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
            &lt;div className="form-group"&gt;
              &lt;label className="col-md-2 control-label"&gt;Age&lt;/label&gt;
              &lt;div className="col-md-3"&gt;
                &lt;div&gt;
                  {current.age}
                &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }
  return &lt;div&gt;{display}&lt;/div&gt;;
}</div></code></pre>
Before we reference the PersonForm in our Details component we need to make some changes to our ViewModel. You will notice that we reference a field on the <code>persons</code> data context called <code>selectedPerson</code>, we will need to add this to our <code>personsViewModel</code>. This field will hold the currently selected Person model.</p>
<p>Open the <code>persons.js</code> file located in the <code>viewModels</code> directory and add the <code>selectedPerson</code> field.
<pre><code><div class="code-block">selectedPerson: {
  kind: 'instance',
  get: function() {
    return this.$state.selectedPerson;
  }
},</div></code></pre>
We only need a getter, because we will be setting this field via a function. We have also used a new <code>kind</code> attribute called <code>instance</code>. This indicates to Astarisx that an Astarisx Model will be stored in this field. Add the following code function to select a person.
<pre><code><div class="code-block">selectPerson: function(id){
  var person;
  if(this.selectedPerson === void(0) || this.selectedPerson.id !== id){     
    for (var i = this.collection.length - 1; i >= 0; i--) {
      if(this.collection[i].id === id){
        person = new Person(this.collection[i]);
        break;
      }
    }
    this.setState({
      selectedPerson: person
    });
  }
}</div></code></pre>
In the function above we loop through the persons collection and test to see if the passed in <code>id</code> matches any of our person id's. If we find a match we create a new Person and assign it to <code>person</code> and break out of the loop. If we don't find a match then the <code>person</code> remains <code>undefined</code>. We then take whatever is stored in <code>person</code> and pass it to <code>setState</code>. This will transition the <code>persons</code> data context to the next state and the <code>selectedPerson</code> field will then hold the new value.</p>
<p><b>n.b. A very important point to note here is that the <code>selectedPerson</code> is not the same object as the one stored in the collection. We have stored a totally new object in <code>selectedPerson</code>. Any changes to <code>selectedPerson</code> or the equivalent person in the collection will not be reflected in the other. I show how everything is kept in sync when we discuss updating models.</b></p>
<p>Let's update the View to utilize this code. We select persons using the PersonList component, so open <code>personList.js</code> and locate the PersonListItem component and add a prop called <code>person</code> and pass it <code>persons</code>. This will make the <code>persons</code> data context available to PersonsItemList. Open <code>personsItemList.js</code> and add the following code.
<pre><code><div class="code-block">handleSelection: function(e){
  e.preventDefault();
  this.props.persons.selectPerson(this.props.person.id);
}</div></code></pre> and update the render function with this
<pre><code><div class="code-block">render: function() {
  var person = this.props.person;
  var persons = this.props.persons;
  var selected = persons.selectedPerson && (person.id === persons.selectedPerson.id);
  return (
    &lt;a onClick={this.handleSelection}
      className={selected ? "list-group-item active" : "list-group-item"} 
      href="#"&gt;{person.fullName}
      &lt;span className="glyphicon glyphicon-trash pull-right"&gt;&lt;/span&gt;
    &lt;/a&gt;
  );
}</div></code></pre>
Select a person from the list and it should get highlighted.</p>
<p><em>If you've been following along, now is a good time to inspect the browser's javascript console. If you still have the console.log code in the UI component, you'll notice that every time you select a person, a new object is sent to the console. This is how Astarisx works. Go ahead poke around the object and inspect the data context fields.</em></p>
<p>OK. That's all well and good but we want to see something. Go to your Details component and reference PersonForm and add it to your component. While you're there you might as well reference HobbyList and include that, because we are working on that next. Here's what Details looks like.
<pre><code><div class="code-block">var React = require('react');
var PersonForm = require('./personForm');
var HobbyList = require('./hobbyList');

var Details = React.createClass({

  displayName: 'Details',
  render: function() {
    return (&lt;div&gt; 
      &lt;PersonForm /&gt;
      &lt;HobbyList /&gt;
    &lt;/div&gt;);
  }
});

module.exports = Details;</div></code></pre>
Now we are going to add the ability to display and select hobbies. This is much the same as what we did to the PersonList so I will simply just give you the code for you to review. Add the following to <code>personsViewModel</code>, outside of the descriptor
<pre><code><div class="code-block">var hobbyCtor = require('../models/hobby');

var Hobby = function(){
    return new hobbyCtor().apply(this, arguments);
};</div></code></pre>
And add/update the relevant code within the <code>personsViewModel</code> descriptor.
<pre><code><div class="code-block">selectPerson: function(id){
  var person;
  if(this.selectedPerson === void(0) || this.selectedPerson.id !== id){     
    for (var i = this.collection.length - 1; i >= 0; i--) {
      if(this.collection[i].id === id){
        person = new Person(this.collection[i]);
        break;
      }
    }
    this.setState({
      selectedPerson: person,
      selectedHobby: void(0)
    });
  }
}, 
selectedHobby: {
  kind: 'instance',
  get: function() { return this.$state.selectedHobby; }
},

selectHobby: function(id){
  var person;
  if(this.selectedPerson !== void(0)){    
    for (var i = this.selectedPerson.hobbies.length - 1; i >= 0; i--) {
      if(this.selectedPerson.hobbies[i].id === id){
        hobby = new Hobby(this.selectedPerson.hobbies[i]);
        break;
      }
    }
    this.setState({
      selectedHobby: hobby
    });
  }
}</div></code></pre>
And here is the HobbyList
<pre><code><div class="code-block">var React = require('react');
var Astarisx = require('astarisx');
var HobbyListItem = require('./hobbyListItem');

var HobbyList = React.createClass({

  displayName: 'HobbyList',
  mixins: [Astarisx.mixin.view],
  render: function() {
    var persons = this.state.appContext.persons;
    var selectedPerson = persons.selectedPerson;
    var hobbies = selectedPerson !== void(0) ? selectedPerson.hobbies : [];
    var list = hobbies.map(function(hobby){
      return (
        &lt;HobbyListItem
          key={hobby.id}
          hobby={hobby}
          persons={persons} /&gt;
      );
    });
    return (
      &lt;div className="list-group"&gt;
        {list}
      &lt;/div&gt;
    );
  }
});

module.exports = HobbyList;</div></code></pre>
and HobbyListItem
<pre><code><div class="code-block">var React = require('react');

var HobbyListItem = React.createClass({

  displayName: 'HobbyListItem',
  handleSelection: function(e){
    e.preventDefault();
    e.stopPropagation();
    this.props.persons.selectHobby(this.props.hobby.id);
  },
  render: function() {
    var hobby = this.props.hobby;
    var persons = this.props.persons;
    var selected = persons.selectedHobby && (hobby.id === persons.selectedHobby.id);
    return (
      &lt;a onClick={this.handleSelection}
        className={selected ? "list-group-item active" : "list-group-item"} 
        href="#"&gt;{hobby.name}
        &lt;span className="glyphicon glyphicon-trash pull-right"&gt;&lt;/span&gt;
      &lt;/a&gt;
    );
  }
});

module.exports = HobbyListItem;</div></code></pre>
</p>
<p>Wow. That was long. But we've got the foundation of the UI. Now we need to add the ability to update the information.</p>

<h3 class="content-subhead" id="updatingmodeldata">Updating Model Data</h3>
<p>React is great. But I found updating model data painful. I had to ensure that my model data was high enough in the component hierarchy to service the right components and then I had to pass data back up the hierarchy chain to a function which updated that data. It all felt a little messy. Astarisx simplifies updating models. By having access to the Application Data Context from anywhere in your application, you can just update any model from any component and all the other components will reflect that change.</p>
<p>We are going to make the PersonForm editable. Open <code>personForm.js</code> and add an empty update function for each field. In each of the input fields add an <code>onChange</code> event and reference the relevant update function. Then in each of the update functions add code that looks like the code below.
<pre><code><div class="code-base">updateName: function(e){
  this.state.appContext.persons.selectedPerson.fullName = e.target.value;
}</div></code></pre>
Add the relevant code to each of the update functions. Within each function we reference the <code>selectedPerson</code> model and assign the new value to the relevant field. This will call the field setter on the model and trigger the a call to <code>setState</code>. If you were to try to update your model now, you would notice that nothing happens. This is because there is another piece the we must complete for it to update. If you recall, in the <a data-scroll href="#constructingmodels">Constructing Models</a> section, we needed to pass in a <code>modelChangeHandler</code> to the model constructor within the Person ViewModel. The <code>modelChangeHandler</code> is what is invoked when a Model calls <code>setState</code>. So we need to go to our PersonsViewModel and add the code that will transition our model and data context to the next state that includes the changes that we have made to our model.
</p>
<p>Open <code>persons.js</code> and locate <code>personChangeHandler</code> and add the following code.
<pre><code><div class="code-block">var personChangeHandler = function(nextState, nextAppState, callback){
  var coll = this.collection.map(function(person){
    if(nextState.id === person.id){
      return new Person(nextState);
    }
    return person;
  });
  this.setState({
    collection: coll, 
    selectedPerson: new Person(nextState)
  });
};</div></code></pre>
When <code>setState</code> is called in our Person model, it will invoke <code>personChangeHandler</code>. One of the arguments passed in is <code>nextState</code> which holds the entire state of the Person model (i.e. the value stored in every field) with the update applied to the appropriate field. We pass <code>nextState</code> to <code>Person</code>, create a new Person with the new state and pass that back to the <code>coll</code> array. The <code>coll</code> array now holds the entire <code>persons</code> collection with the new modified Person. This gets passed to <code>setState</code> to transition the data context. We must also update <code>selectedPerson</code>, if not the UI will only reflect the change in the PersonList and not the PersonForm, as the PersonForm's data source is <code>selectedPerson</code>. So we create a new Person based on the next state and pass that to <code>selectedPerson</code> in <code>setState</code>. Now I didn't have to do it like this, we could have stored a reference to the newly created Person as we were looping through the collection, then pass that reference to <code>setState</code>, but I wanted to emphasize an important point. <b>The model that is stored in <code>collection</code> is not the same model that is stored in <code>selectedPerson</code> they are two different model objects that have the same state.</b> Anyway, after adding the above code your model will transition to the next state and the changes will be reflected in the UI for both the PersonForm and the PersonList.
</p>
<p><b>n.b. For this to work, the model to be updated needs to be associated with a field that has a <code>kind</code> attribute with a value of <code>instance</code> (i.e <code class="wrap">kind:'instance')</code>. The reason for this is that only fields of kind instance have a <code>modelChangeHandler</code> associated with them, which is key to this process.</b></p>

<p>OK. Now let's add the ability to update a hobby. Go to your HobbyList and add an input above the "list-group"
<pre><code><div class="code-block">&lt;input
  className="form-control" 
  type="text" 
  value={selectedHobby ? selectedHobby.name : ''}
  onChange={this.updateHobby} 
  placeholder="Select hobby to update"/&gt;</div></code></pre>
  You will need to reference <code>selectedHobby</code> on the <code>persons</code> data context and add an <code>updateHobby</code> function. Now, go back to the PersonViewModel. We need to add code that will transition the data context to the next state. This is similar to what we did for the Person model, except it is a little different because the Hobby model is not the primary model, as it is embedded in Person Model, so we need to ensure that the <code>selectedHobby</code> has a <code>modelChangeHandler</code> associated to it.</p> 
  <p>In the Person ViewModel ensure that you have a reference to the Hobby Model and add the following code.

  <pre><code><div class="code-block">var hobbyCtor = require('../models/hobby');

var hobbyChangeHandler = function(nextState){
};

var Hobby = function(){
    return new hobbyCtor(hobbyChangeHandler).apply(this, arguments);
};</div></code></pre>
Then change the <code>selectedHobby</code> field getter to the following.
  <pre><code><div class="code-block">selectedHobby: {
  kind: 'instance',
  get: function() { return new Hobby(this.$state.selectedHobby); }
}</div></code></pre>
Everytime a hobby is selected, it returns a new Hobby associated with <code>hobbyChangeHandler</code>. Great but <code>hobbyChangeHandler</code> doesn't do anything. So lets add some code. Update <code>hobbyChangeHandler</code> to
<pre><code><div class="code-block">var hobbyChangeHandler = function(nextState){
  var hobbies = this.selectedPerson.hobbies.map(function(hobby){
    if(nextState.id === hobby.id){
      return nextState;
    }
    return hobby;
  });
  var newPerson = new Person(this.selectedPerson, {hobbies: hobbies});
  var nextAppState = {};
  nextAppState[this.$dataContext] = {selectedHobby: new Hobby(nextState)};
  personChangeHandler.call(this, newPerson, nextAppState);
};</div></code></pre>
OK, so what is this code doing. Well firstly we loop through the currently selected person's hobbies and if we find a match with the <code>nextState</code> we return <code>nextState</code>. Notice that I am not creating a new Hobby like we did for the Person code above. That is because the hobbies collection gets instantiated by the Person Model, so I don't need to do it here. So then I create a new Person with the updated hobbies array. You will notice that the Person constructure gets two arguments. The reason is that the constructor will automatically merge the new state <code>{hobbies: hobbies}</code> with the existing state <code>this.selectedPerson</code> to creaet a new Person with the new state (i.e. updated hobby). The next bit of code requires a little explaining.</p>
<p>I now have a new Person with the updated hobby. I need to transition the <code>persons</code> data context to the next state with that new Person. To do this I will need to update <code>selectedPerson</code> and <code>collection</code> otherwise the models will become out of sync. Now I could write a block of code to loop through the <code>collection</code> and update it with the new Person, which is exactly what <code>personChangeHandler</code> does or I could just use <code>personChangeHandler</code>. So I use <code>personChangeHandler</code>. To use <code>personChangeHandler</code> I need to ensure that it will use the correct context, so I invoke it using <code>call</code> and pass in <code>this</code>, then I pass it <code>newPerson</code>, which is the entire state of the new Person and it gets assigned to <code>nextState</code>. But what about <code>selectedHobby</code> that too needs to be updated. To update <code>selectedHobby</code> I pass a second argument to <code>personChangeHandler</code>. The second argument gets assigned to <code>nextAppState</code> as is passed straight to <code>setState</code> as the second argument. The format for <code>nextAppState</code> is a litte different. It expects an object that has a key that represents a data context name, <code>persons</code> in this instance, and then the fields that will need to be updated, which is <code>selectedHobby</code>. <code>setState</code> will take this object and merge the state and ensure that all the specified data contexts are updated accordingly. So ensure that you pass <code>nextAppState</code> as the second argument to <code>setState</code> in <code>personChangeHandler</code>. <em>As a side note, <code>setState</code>'s' <code>nextAppState</code> argument can take ControllerViewModel fields directly, there is no need to specify a data context for them, and it also takes directives. Please refer to the API.</em></p>

<h3 class="content-subhead" id="addingmodels">Adding Models</h3>
<p>Our CRM needs to cater to more than 3 people, so let's add the ability to add models. First we update the Person ViewModel and add an <code>addPerson</code> function to the descriptor with the following code.
<pre><code><div class="code-block">addPerson: function(fullName){
  var nextState = {};
  var name;

  if(fullName && fullName.length > 0){
    name = fullName.split(' ');
    nextState.selectedPerson = new Person({
      firstName: name[0],
      lastName: name.slice(1).join(' ')
    });
    nextState.collection = this.collection.slice(0);
    nextState.collection = nextState.collection.concat(nextState.selectedPerson);
    this.setState(nextState);
  }
}</div></code></pre>
The function is pretty straight forward. We take an argument with the person's full name and assign it to <code>firstName</code> and <code>lastName</code>. We can't just assign a value to the <code>pseudo</code> field <code>fullName</code> during instantiation. Once the model has been created can we pass updates to the <code>fullName</code> field. So we update the Navigation component to include an input field to accept the new person's name. The code is below for your review.
<pre><code><div class="code-block">var React = require('react');
var PersonList = require('./personList');
var Astarisx = require('astarisx');

var Navigation = React.createClass({
  mixins: [Astarisx.mixin.view],
  displayName: 'Navigation',
  addPerson: function(){
    this.state.appContext.persons.addPerson(this.state.newValue);
    this.setState({
      newValue: ""
    });
  },
  update: function(e){
    this.setState({
      newValue: e.target.value
    });
  },
  getInitialState: function() {
    return {
      newValue: "" 
    };
  },
  render: function(){
    return (
      &lt;div&gt;
        &lt;div className="input-group"&gt;
          &lt;input value={this.state.newValue}
            onChange={this.update}
            type="text" className="form-control" 
            placeholder="Full Name"/&gt;
          &lt;span className="input-group-btn"&gt;
            &lt;button onClick={this.addPerson} 
              className="btn btn-default" 
              type="button"&gt;Add&lt;/button&gt;
          &lt;/span&gt;
        &lt;/div&gt;
        &lt;PersonList /&gt;
      &lt;/div&gt;
    );    
  }
});

module.exports = Navigation;</div></code></pre>
And adding hobbies is very similar to adding persons, except that you add the add function to the Person model and not to the Persons ViewModel
<pre><code><div class="code-block">addHobby: function(hobbyName){
  var newHobbiesArr = this.hobbies.concat(new Hobby({hobby: hobbyName}));
  this.setState({hobbies: newHobbiesArr});
}</div></code></pre>
and the HobbyList should look like this.
<pre><code><div class="code-block">var React = require('react');
var Astarisx = require('astarisx');
var HobbyListItem = require('./hobbyListItem');

var HobbyList = React.createClass({
  updateHobby: function(e){
    this.state.appContext.persons.selectedHobby.name = e.target.value;
  },
  displayName: 'HobbyList',
  mixins: [Astarisx.mixin.view],
  addHobby: function(){
    this.state.appContext.persons.selectedPerson.addHobby(this.state.newValue);
    this.setState({
      newValue: ""
    });
  },
  update: function(e){
    this.setState({
      newValue: e.target.value
    });
  },
  getInitialState: function() {
    return {
      newValue: "" 
    };
  },
  render: function() {
    var persons = this.state.appContext.persons;
    var selectedPerson = persons.selectedPerson;
    var selectedHobby = persons.selectedHobby;
    var hobbies = selectedPerson !== void(0) ? selectedPerson.hobbies : [];
    var list = hobbies.map(function(hobby){
      return (
        &lt;HobbyListItem
          key={hobby.id}
          hobby={hobby}
          persons={persons} /&gt;
      );
    });
    return (&lt;div&gt;
      &lt;div className="input-group"&gt;
        &lt;input value={this.state.newValue}
          onChange={this.update}
          type="text" 
          className="form-control" 
          placeholder="What do you like doing in your spare time?"/&gt;
        &lt;span className="input-group-btn"&gt;
          &lt;button onClick={this.addHobby} 
            className="btn btn-default"
            type="button"&gt;Add&lt;/button&gt;
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;input className="form-control" type="text" 
        value={selectedHobby ? selectedHobby.name : ''}
          onChange={this.updateHobby}
          placeholder="Select hobby to update"/&gt;
      &lt;div className="list-group"&gt;
        {list}
      &lt;/div&gt;
    &lt;/div&gt;);
  }
});

module.exports = HobbyList;</div></code></pre>
</p>
<h3 class="content-subhead" id="deletingmodels">Deleting Models</h3>
<p>Deleting models is nothing special and the approach used is a matter of preference. You could adopt an approach similar to that used for adding models except you're removing items from the array. It's up to you and I'll leave that as an excercise for you to complete.</p>
<h3 class="content-subhead" id="enable undo">Enable Undo</h3>
<p>Astarisx has built in support for Undo/Redo functionality. To enable it you pass an <code>enableUndo</code> option with a value of <code>true</code> during Application Data Context intialization. So if you go back to the UI component (<code>ui.js</code>) and update <code>componentWillMount</code> to
<pre><code><div class="code-block">componentWillMount: function(){
  this.initializeAppContext({ 
    controllerViewModel: cvm,
    enableUndo: true
  });
}</div></code></pre>
This will give you some extra functions and properties that allow you to navigate back and forth through the state of your application. Let's add some undo and redo functionality. First add a reference to Astarisx and add the <code>Astarisx.mixin.view</code> mixin then update your MenuBar render function to include the two new buttons.
<pre><code><div class="code-base">render: function(){

  return (
    &lt;nav className="navbar navbar-default" role="navigation"&gt;
      &lt;div className="container-fluid"&gt;
        &lt;div className="navbar-header"&gt;
          &lt;button type="button"
          className="navbar-toggle"
          data-toggle="collapse"
          data-target="#bs-example-navbar-collapse-1"&gt;
            &lt;span className="sr-only"&gt;Toggle navigation&lt;/span&gt;
            &lt;span className="icon-bar"&gt;&lt;/span&gt;
            &lt;span className="icon-bar"&gt;&lt;/span&gt;
            &lt;span className="icon-bar"&gt;&lt;/span&gt;
          &lt;/button&gt;
          &lt;a className="navbar-brand" href="#"&gt;
            Astarisx CRM
          &lt;/a&gt;
        &lt;/div&gt;
        {/* New Buttons*/}
        &lt;div ref="menu" className="collapse navbar-collapse"&gt;
          &lt;form className="navbar-form pull-right" role="search"&gt;
            &lt;button onClick={this.undo}
              disabled={!this.state.appContext.$canRevert}
              className="btn btn-default btn-sm"&gt;
            Undo
            &lt;/button&gt;
             &lt;button onClick={this.redo}
              disabled={!this.state.appContext.$canAdvance}
              className="btn btn-default btn-sm"&gt;
            Redo
            &lt;/button&gt;
          &lt;/form&gt;
        &lt;/div&gt;

      &lt;/div&gt;
    &lt;/nav&gt;
  );
}</div></code></pre>
Then add a redo and undo function.
<pre><code><div>undo: function(e){
  e.preventDefault();
  e.stopPropagation();
  this.state.appContext.revert();
},
redo: function(e){
  e.preventDefault();
  e.stopPropagation();
  this.state.appContext.advance();
}</div></code></pre>
You can analyze the code later. For now save your work and go and update some data. Every state change is captured. You are able to navigate back and forth through your application's state. Even deletes can be undone. However, there's an issue with the undo button. It is enabled even though you haven't changed anything. This is because Astarisx has actually gone through a state change during initialization and therefore does in fact have previous state. To fix this we need to pass a simple argument to the initial <code>setState</code> call. Go to the Persons ViewModel and locate <code>dataContextWillInitialize</code> and update <code>setState</code> by adding a second argument of <code>false</code>. This tells Astarisx to not retain the previous state for this particular state transition.
<pre><code><div class="code-block">self.setState({
  collection: personsCollection
}, false);</div></code></pre></p>


<h3 class="content-subhead" id="movingstuffaround">Moving Stuff Around</h3>
<p>One of the major benefits of using Astarisx is that UI components are Highly Composable. They can be easily moved around within your application without breaking your code.</p>
<p>Our CRM application has a little issue that I think we should address. When you start the application, you can see the inputs fields that belong to the HobbyList. They shouldn't be seen until a Person is selected. So let's move HobbyList to a more appropriate location.</p>
<p>Open the Details component and delete all references to HobbyList. Then open the PersonForm and add a reference to HobbyList and add the component just below the closing <code>form</code> tag. Save your work and take a look at the CRM application. As you can see the input fields are no longer there and the application works as expected. We were able to shift the HobbyList component without breaking a thing.</p>


<h2 class="content-subhead" id="enhancingtheapplication">Enhancing the Application</h2>
<h3 class="content-subhead" id="stilltocome">Still to come.</h3>

            <!-- <h2 class="content-subhead" id="#tips">Tips</h2>
            <h2 class="content-subhead" id="#videos">Videos</h2>
            <h2 class="content-subhead" id="#resources">Resources</h2> -->

            
        </div>
    </div>
</div>



<script src="../lib/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="js/ui.js"></script>
<script src="../lib/smooth-scroll.js"></script>
<script>
    smoothScroll.init({
      speed: 1000, // Integer. How fast to complete the scroll in milliseconds
    easing: "easeInOutCubic", // Easing pattern to use
    // updateURL: false, // Boolean. Whether or not to update the URL with the anchor hash on scroll
    // offset: 80, // Integer. How far to offset the scrolling anchor location in pixels
    // callbackBefore: function ( toggle, anchor ) {}, // Function to run before scrolling
    // callbackAfter: function ( toggle, anchor ) {} // Function to run after scrolling
    });
</script>


</body>
</html>
