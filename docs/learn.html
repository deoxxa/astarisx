<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Astarisx Documentation</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow-night-bright.min.css">
  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
    <!--<![endif]-->

</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>

    <div id="menu">
        <div class="pure-menu pure-menu-open">
            
            <a class="pure-menu-heading" href="../index.html"><span class="fa fa-arrow-left"></span>Astarisx</a>

            <ul>
                <li class="group-header"><a data-scroll href="#tutorial">Building a Simple CRM</a></li>
                <li class="sub"><a data-scroll href="#projectsetup">Project Setup</a></li>
                <li class="sub"><a data-scroll href="#applicationstructure">Application Structure</a></li>
                <li class="group-header"><a data-scroll href="#basic">Basic Application</a></li>
                <li class="sub"><a data-scroll href="#creatingthemodels">Creating the Models</a></li>
                <li class="sub"><a data-scroll href="#creatingaviewmodel">Creating a ViewModel</a></li>
                <li class="sub"><a data-scroll href="#constructingmodels">Constructing Models</a></li>
                <li class="sub"><a data-scroll href="#exposingadatacontext">Exposing a Data Context</a></li>
                <li class="sub"><a data-scroll href="#buildingtheui">Building the UI</a></li>
                <li class="sub"><a data-scroll href="#buildtheui">Enable Undo</a></li>
                <li class="sub"><a data-scroll href="#buildtheui">MediaQuery Notifications</a></li>
                <li class="sub"><a data-scroll href="#buildtheui">From React to Astarisx Views</a></li>
                <li class="sub"><a data-scroll href="#buildtheui">pushState Routing</a></li>
                <li class="sub"><a data-scroll href="#buildtheui">Adding Transitions</a></li>
                <!-- <li class="group-header"><a data-scroll href="#tips">Tips</a></li>
                <li class="group-header"><a data-scroll href="#videos">Videos</a></li>
                <li class="group-header"><a data-scroll href="#resources">Resources</a></li> -->
            </ul>
        </div>
    </div>

    <div id="main">
        <div class="header">
            <h1>Astarisx Tutorial</h1>
            <h2>Work in progress</h2>
        </div>

        <div class="content">
            <h2 class="content-subhead" id="tutorial">Building a Simple CRM</h2>
            <p>We are going to be build a simple CRM application. The application is a little contrived but will serve to demonstrate most of the concepts within Astarisx. We"ll start by building a basic version and add functionality as we go until we have a our completed CRM. If you would like to follow along with this tutorial, you need <a href="http://nodejs.org/">Node.js</a> and <a href="http://gulpjs.com/">gulp</a> installed. It is assumed that you are familar with <a href="http://facebook.github.io/react/">React</a>.</p>
            
            <p>The application should end up looking something like this.</p>
            <img class="pure-img" src="../img/ScreenShot_Example.png">
            <p>The source code of the completed application for this tutorial can be found on <a href="">GitHub (To be set)</a></p>
            

            <h3 class="content-subhead" id="projectsetup">Project Setup</h3>
            <p>After ensuring you have Node and gulp installed, run the following command in a terminal.</p>
            <pre><code><div class="code-block">git clone https://github.com/entrendipity/astarisx-starterkit.git</div></code></pre>
            <p>This will create a directory called <code>astarisx-starterkit</code> which will give us a basic project structure to work with. <em>If you don"t have <a href="http://git-scm.com/">git</a> installed, you can <a href="https://github.com/entrendipity/astarisx-starterkit/archive/master.zip">download the starter kit from here</a> and extract it into a directory.</em></p>

            <p>Before we go any further we should take a look at what the starter kit has given us.</p>
            <p>The starter kit gives us a basic project structure and some tools to develop our app. In the root directory we have a <code>gulpfile.js</code> used to configure gulp tasks, a package.json and README.md files, nothing that you need to worry about for what we are doing, and an <code>index.html</code>, main.js and app directory. The last the things are what we care about. Let"s take a look.</p>
            <p>The <code>index.html</code> file, although relevant, is nothing special. If you"ve written a React application you will now that the <code>index.html</code> file is just the container that holds your application. So let"s move onto to <code>main.js</code></p>
            <pre><code><div class="code-block">/* main.js */
var React = require("react"),
  App = require("./app/view/ui");

module.exports = React.render(&lt;App /&gt;, document.body);</div></code></pre>
<p>Again nothing really to see here, we are simply initializing the application as per normal.</p>
<p>The <code>app</code> directory is a little more interesting. It is made up of three directories, <code>models</code>, <code>view</code> and <code>viewModels</code>. This is where the code for our application will be stored. The <code>models</code> directory has a <code>models.txt</code> file in it, acting as a place holder and it can be deleted. We"ll put our models in here later. The <code>viewModels</code> directory has a file called <code>cvm.js</code> this is the most basic ControllerViewModel that you can create. We need a reference to the ControllerViewModel from the View. So in the <code>view</code> directory we have a file called <code>ui.js</code>, this is the file that was referenced in <code>main.js</code> and is what Astarisx refers to as the UI Container, as it will hold all the other components. Let"s crack it open.</p>
<pre><code><div class="code-block">/* ui.js */
var React = require("react");
var Astarisx = require("astarisx");
var cvm = require("../viewModels/cvm");

var UI = React.createClass({
  mixins: [Astarisx.mixin.ui],
  componentWillMount: function(){
    this.initializeAppContext({ 
      controllerViewModel: cvm
    });
  },

  render: function(){
    return (&lt;h1&gt;All OK!&lt;/h1&gt;);
  }
});
module.exports = UI;</div></code></pre>

    <p>This is where we are reference the ControllerViewModel (i.e. <code class="wrap">var cvm = require("../viewModels/cvm")</code>. It is passed into the <code>initializeAppContext</code>, within the <code>componentWillMount</code>, and will initialize the Application Data Context. An important thing to note, is that we mixin <code class="wrap">Astarisx.mixin.ui</code>. This turns the React component into an Astarisx UI Container. It will attach a special property called <code>appContext</code> to the component"s state object. We will be referencing <code>appContext</code> alot.</p>

    <p>Now rename the <code>astarisx-starterkit</code> directory to <code>astarisx-tutorial</code>. Navigate into the <code>astarisx-tutorial</code> and run <code>npm install</code>.</p>
            <pre><code><div class="code-block">npm install</div></code></pre>
            <p>This will download and install the required components to build your app. You will notice that a <code>node_modules</code> directory was created. This is where our modules live. Once that is done, run the following command.</p>
            <pre><code><div class="code-block">gulp serve</div></code></pre>
            <p>This will start a local http server and (hopefully) open a web browser displaying the application. It should have also created two new root directories called <code>build</code> and <code>assets</code>. This is where our compiled files land for our application. Keep the terminal window open and the browser should automatically update as we make changes.</p>

            <h3 class="content-subhead" id="applicationstructure">Application Structure</h3>
            <p>Our application is going to have the following Astarisx object:
                <ul>
                    <li>Person Model</li>
                    <li>Hobby Model</li>
                    <li>Persons ViewModel</li>
                    <li>persons Data Context</li>
                </ul>
                We'll be using the following demo data.
                <pre><code><div class="code-block">/* Demo Data */
[{
    "id": "1",
    "firstName": "Frank",
    "lastName": "Smith",
    "gender": "male",
    "dob": "1980-03-03",
    "job": "Dentist",
    "hobbies": [{"id": "1", "hobby": "reading"},
        {"id": "2", "hobby": "golfing"},
        {"id": "3", "hobby": "cutting code"}]
},{
    "id":"2",
    "firstName": "Lisa",
    "lastName": "Jones",
    "gender": "female",
    "dob": "1985-02-22",
    "job": "Accountant",
    "hobbies": [{"id": "1", "hobby": "reading"}]
},{
    "id": "3",
    "firstName": "John",
    "lastName": "Citizen",
    "gender": "male",
    "dob": "1975-12-11",
    "job": "Unemployed",
    "hobbies": [{"id": "1", "hobby": "watching YouTube"}]
}]</div></code></pre>

            </p>
            <p>OK, let"s get started.</p>
            <h2 class="content-subhead" id="basic">Basic Application</h2>

            
            
            <h3 class="content-subhead" id="creatingthemodels">Creating the Models</h3>
            <p>In the <code>models</code> directory create a file called <code>person.js</code> and add the following code.
            <pre><code><div class="code-block">/* models/person.js */
var Astarisx = require('astarisx');

var person = Astarisx.createModelClass({

  id: {
    get: function(){
      return this.$state.id;
    }
  },
  
  firstName: {
    get: function(){ 
      return this.$state.firstName; 
    },
    set: function(newValue){
      this.setState({firstname: newValue});
    }
  },

  lastName: {
    get: function(){ 
      return this.$state.lastName; 
    },
    set: function(newValue){
      this.setState({lastName: newValue});
    }
  },

  job: {
    get: function(){
      return this.$state.job;
    },
    set: function(newValue){
      this.setState({'job': newValue});
    }
  },

  dob: {
    get: function(){
      return this.$state.dob;
    },
    set: function(newValue){
      this.setState({'dob': newValue});
    }
  },

  gender: {
    get: function(){ 
      return this.$state.gender; 
    },
    set: function(newValue){
      this.setState({'gender': newValue});
    }
  },

  hobbies: {
    kind: 'array',
    get: function(){
      return this.$state.hobbies;
    }
  }

});

module.exports = person;</div></code></pre>
            We create a field with the same name for each of the fields in the source object. Apart from the <code>id</code> and <code>hobbies</code> fields, each field has a getter and setter. The getter returns whatever is stored in the <code>$state</code> object. The setter sets the value of the field using <code>setState</code> which triggers a state transition. The new value will be stored in <code>$state</code> once the state transition has completed. The reason that <code>id</code> does not have a setter is that we want to prevent anything from changing it's state. <code>hobbies</code> is an array, so we specify the <code>kind</code> attribute with the value array. Astarisx needs to know which fields are arrays becuase they require some extra attention. You don't need to worry about that, Astarisx takes care of it for you. It doesn't need a setter because all updates to arrays are done via method calls.</p>
            <p>We don't have to define a field for every key in our source data. If we decided not to the value would not be lost, it would simply form part of the object's state (i.e. <code>this.$state</code>). 
            </p>
            <p>Before we move on, we need to update the <code>job</code> field. We would prefer that the <code>job</code> field was called <code>occupation</code>. To transform <code>job</code> to <code>occupation</code> we use the <code>aliasFor</code> attribute. The job field should now look like this.
            <pre><code><div class="code-block">occupation: {
  aliasFor: 'job',
  get: function(){
    return this.$state.occupation;
  },
  set: function(newValue){
    this.setState({'occupation': newValue });
  }
}</div></code></pre>
Whenever a Person model is referenced, you will use <code>occupation</code> like a regular model field, instead of <code>job</code>. When you persist this model back to the data store, Astarisx sends the <code>occupation</code> field as "occupation". If this is not what you would like, then you need to transform <code>occupation</code> back to <code>job</code> before it is sent to the server. Astarisx provides a convenience method called <code>transpose</code>, which replaces model fields with whatever name you like. Another approasch to transforming fileds is to use the <code>kind</code> attribute with a value of <code>pseudo</code>. We will use this approach in the Hobby model below.
            </p>
            <p>Next we create the <code>hobby</code> model.
            <pre><code><div class="code-block">/* models/hobby.js */
var Astarisx = require('astarisx');

var hobby = Astarisx.createMClass({

  id: {
    get: function(){
      return this.$state.id;
    }
  },

  hobby: {
    get: function(){
      return this.$state.hobby;
    },
    set: function(newValue){
      this.setState({'hobby': newValue });
    }
  }
});

module.exports = hobby;</div></code></pre>
The Hobby model has two fields, <code>id</code> and <code>hobby</code>. We would like to reference the <code>hobby</code> as <code>name</code> in the View, but when it gets saved to the data store we still want it to be stored as <code>hobby</code>. We can define a pseudo field to accomplish this. A pseudo field is a field that does not retain it's value. It must get it's value from so other source. In this instance we are going to use <code class="wrap">this.$state.hobby</code> as the source for the pseudo field <code>name</code>. Pseudo fields are non-enumerable and are not stored in an object's <code>$state</code> object, so won't form part of the payload when being sent to the server.
<pre><code><div class="code-block">
  name: {
    kind: 'pseudo',
    get: function(){
      return this.$state.hobby;
    },
    set: function(newValue){
      this.setState({'hobby': newValue });
    }
  }
  
</div></code></pre>
 Add another field called <code>name</code> ensuring to include the <code>kind</code> attribute with a value of <code>pseudo</code>. Notice that the pseudo field <code>name</code> gets it's value from <code class="wrap">this.$state.hobby</code> and will set the <code>hobby</code> field. We still need the <code>hobby</code> field available for this to work. So the View will see both <code>hobby</code> and <code>name</code>, but the server will only see <code>hobby</code>. If you like you can remove the setter from the <code>hobby</code> field and this will still work, however all updates will need to be done via the <code>name</code> field.</p>
            
            <h3 class="content-subhead" id="creatingaviewmodel">Creating a ViewModel</h3>
            <p>Now let's create a ViewModel that will reference the models created above. Create a file called <code>persons.js</code> in the <code>viewModels</code> directory. This file will hold the personsViewModel, which will store a collection of <code>person</code> model objects.
            <pre><code><div class="code-block">var Astarisx = require('astarisx');
var personsViewModel = Astarisx.createViewModelClass({
});
module.exports = personsViewModel;</div></code></pre>
The above code creates an empty ViewModel. We need to fill it will <code>person</code> models. But first we should reference this module in the ControllerViewModel. Place the code below somewhere at the top of <code>cvm.js</code>.
<pre><code><div class="code-block">var PersonViewModel = require('./persons');</div></code></pre>
Requiring our PersonViewModel module let's gulp know that it needs to watch the <code>persons.js</code>. It will now be parsed and compiled and the browser will update whenever we make a change to it. </p>



<h3 class="content-subhead" id="constructingmodels">Constructing Models</h3>
<p>So back to the ViewModel. Create a reference to your model by requiring <code>person.js</code>.
            <pre><code><div class="code-block">var Astarisx = require('astarisx');
var personCtor = require('../models/person');

var personsViewModel = Astarisx.createViewModelClass({
});
module.exports = personsViewModel;</div></code></pre>
We store the model reference in a variable called <code>personCtor</code>, you could call it anything you like, but why have I referred to it as <code>personCtor</code>. Astarisx objects actually return object constructors. Astarisx automatically instantiates ViewModels and the ControllerViewModel for you, so you never have to worry about them. Models are not automatically instantiated. The reason is that models need additional information. We use the Model constructor to create a function that we then use to instantiate a model at runtime, so we need to add a little boiler plate code. It looks like this
<pre><code><div class="code-block">var Person = function(){
    return new personCtor().apply(this, arguments);
};</div></code></pre>
This code sits outside of the ViewModel descriptor, like so...
            <pre><code><div class="code-block">var Astarisx = require('astarisx');
var personCtor = require('../models/person');

var Person = function(){
    return new personCtor().apply(this, arguments);
};

var personsViewModel = Astarisx.createViewModelClass({
});

module.exports = personsViewModel;</div></code></pre>
The <code>Person</code> function allows us to instantiate a <code>Person</code> model by calling <code>new Person()</code> from within the ViewModel descriptor. However, the <code>personCtor</code> takes an optional argument, which is a <code>modelChangeHandler</code>. This is the piece that the model needs at runtime. We are going to call it <code>personChangeHandler</code>. Let's create it now.
<pre><code><div class="code-block">var Astarisx = require('astarisx');

var personCtor = require('../models/person');

var personChangeHandler = function(nextState, nextAppState, callback){
    
};

var Person = function(){
    return new personCtor(personChangeHandler).apply(this, arguments);
};

var personsViewModel = Astarisx.createViewModelClass({
});

module.exports = personsViewModel;</div></code></pre>
We will add some code to the <code>personChangeHandler</code> later, but for now we just pass it into <code>personCtor</code>. What this does is associates <code>personChangeHandler</code> with the ViewModel's data context at the time it is instantiated. So everytime <code>new Person()</code> is called we grab the <code>personChangeHandler</code> with the current data context. It's not important to fully understand this concept at this point, it will become apparent as to what all this means as you use Astarisx, .
</p>
<p>We will need to a Hobby model to the Person Model, as hobby is an array of objects in the source object. So add the following code to the top of<code>person.js</code> model.
<pre><code><div class="code-block">var hobbyCtor = require('./hobby');

var Hobby = function(){
    return new hobbyCtor().apply(this, arguments);
};</div></code></pre>
Then within the <code>person</code> descriptor add a <code>getInitialState</code> that will be used to create the Hobby models whenever a Person model is instantiated.
<pre><code><div class="code-block">getInitialState: function(){
  var arr = this.$state.hobbies.map(function(hobby){
    return new Hobby(hobby);
  });
  return { hobbies: arr };
}</div></code></pre>
When you create a Person object, you pass in the current state, that current state includes the 'hobbies' array, which we reference using <code class="wrap">this.$state.hobbies</code>. We iterate over that array and for each item, we instantiate a Hobby obect and store it in an array called <code>arr</code>. We then return an object that specifies that the <code>hobbies</code> field is to be initialized with the <code>arr</code> array. The <code>hobbies</code> field is an Astarisx array that now holds Astarisx model objects.</p>
<p>OK, let's start populating our personsViewModel with some data. In the root project directory, create a directory called <code>data</code>. Within that directory create a file and cut and paste the demo data above into that file and save it as <code>demo.js</code>. This will act as our source data.</p>

<p>Then back in the <code>personsViewModel</code> descriptor create a field called <code>collection</code>. This is where we are going to store the person model instances. 
<pre><code><div class="code-block">collection: {
  kind: 'array',
  get: function(){ return this.$state.collection; },
}
</div></code></pre>
<code>collection</code> is an Array, so we assign a <code>kind</code> attribute with a value of <code>array</code>. We also define <code>dataContextWillInitialize</code>.
<pre><code><div class="code-block">dataContextWillInitialize: function(){
  var self = this;
  var xhr = new XMLHttpRequest();
  xhr.open('GET', './data/demo.json', true);
  xhr.onload = function(e) {
    if (this.status == 200) {
      var persons = JSON.parse(this.response);
      if(!!persons){
        var personsCollection = persons.map(function(person){
          return new Person(person);
        });
        self.setState({
          collection: personsCollection
        });
      }
    }
  };
  xhr.send();
}</div></code></pre>
<code>dataContextWillInitialize</code> is where you make ajax calls and initialize data for the ViewModel. You do not make ajax calls in <code>getInitialState</code>. Once the server returns with our data, we populate <code>personsCollection</code> with new model instances, then call <code>setState</code> to transition the <code>personsViewModel</code> to the next state with <code>collection</code> holding the new models.
</p>


            <h3 class="content-subhead" id="exposingdatacontext">Exposing a Data Context</h3>

<p>Switch over to the ControllerViewModel. We are going to setup and intialize the <code>persons</code> data context. The data context is what will be exposed to the View, once defined in the ControllerViewModel, the View will have visibility of it and will be able to access it's fields and mthods.</p>

<p> Within the <code>cvm.js</code> file add a <code>dataContextWillInitialize</code> function to the ControllerViewModel descriptor. Within that function initialize all data contexts by calling <code class="wrap">this.initializeDataContext('*');</code>. Of course this has no affect because we haven't defined a data context as yet. So let's do that. Add the following code to the descriptor.

<pre><code><div class="code-block">persons: {
    viewModel: personsViewModel,
    get: function(){
      return this.$state.persons;
    }
}</div></code></pre>
We create a field with the name <code>persons</code>. <code>persons</code> will be the name of the data context and what the View will see. We add a special attribute, called <code>viewModel</code>, to the field. This allows us to associate a ViewModel to the data context. We pass it a reference to our <code>personsViewModel</code>. Your ControllerViewModel should now look like this.

<pre><code><div class="code-block">var Astarisx = require('astarisx');
var personsViewModel = require('./persons');

var controllerViewModel = Astarisx.createCVMClass({
  dataContextWillInitialize: function(){
    this.initializeDataContext('*');
  },
  persons: {
    viewModel: personsViewModel,
    get: function(){
      return this.$state.persons;
    }
  }
});

module.exports = controllerViewModel;</div></code></pre>
When you run your application the ControllerViewModel's <code>dataContextWillInitialize</code> will be called invoking <code>intializeDataContext</code> which will call the <code>personsViewModel</code>'s <code>dataContextWillInitialize</code> which will call <code>setState</code> and populate the collection by transitioning to the next state. So your collection should have 3 person models in it.</p>

<b><em>Because we haven't set up the View to display data as yet, you can't see anything. What I like to do is place this
<pre><code><div class="code-block">console.log('Application State --> ', this.state.appContext);</div></code></pre> at the top of the <code>render</code> function in <code>ui.js</code>, then open the browser's javascript console and inspect the object. The object will have a key called 'persons', this is the data context that we exposed to the View from the ControllerViewModel.</em></b>

</p>

    <h3 class="content-subhead" id="buildingtheui">Building the UI</h3>
    <p>It is assumed that you understand how to build React components, so discussions on how to build React components or React features are glossed over.</p>
    <p>The first thing we need to do is reference Twitter's <a href="http://getbootstrap.com/">Bootstrap</a> library so that we can use the grid and css. Add this to your index.html head.
    <pre><code><div class="code-block">&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css"&gt;</div></code></pre>
    </p>
    <p>
    The UI is comprised of the following components.
    <ul>
        <li>UI (ui.js) - Astarisx UI Container</li>
        <li>MenuBar (menuBar.js)</li>
        <li>Navigation (navigation.js) - Person selector</li>
        <li>Details (details.js) - displays details and hobbies of a selected Person</li>
        <li>PersonForm (personForm.js) - displays details of a selected Person</li>
        <li>PersonList (personList.js) - The List of People</li>
        <li>PersonListItem (PersonListItem.js)</li>
        <li>HobbyList (hobbyList.js) - List of Person's hobbies</li>
        <li>HobbyListItem (hobbyListItem.js)</li>
    </ul>
    Let's revisit <code>ui.js</code>. This is the component that will hold all of the application's components. We have already mixed in <code class="wrap">Astarisx.mixin.ui</code> and placed initialization code and  referenced our ControllerViewModel within the <code>componentWillMount</code> function. So we can start creating our Astarisx View components.
    </p>
    <p>The first component we are going to create is the MenuBar. Create a file called <code>menuBar.js</code> in the <code>views</code> directory and add the following code and save it.
    <pre><code><div class="code-block">var React = require('react');

var Component = React.createClass({

  displayName: 'MenuBar',
  render: function(){
    return (
      &lt;nav className="navbar navbar-default" role="navigation"&gt;
        &lt;div className="container-fluid"&gt;
          &lt;div className="navbar-header"&gt;
            &lt;button type="button"
            className="navbar-toggle"
            data-toggle="collapse"
            data-target="#bs-example-navbar-collapse-1"&gt;
              &lt;span className="sr-only"&gt;Toggle navigation&lt;/span&gt;
              &lt;span className="icon-bar"&gt;&lt;/span&gt;
              &lt;span className="icon-bar"&gt;&lt;/span&gt;
              &lt;span className="icon-bar"&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;a className="navbar-brand" href="#"&gt;
              Astarisx CRM
            &lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/nav&gt;
    );
  }
});

module.exports = Component;</div></code></pre>
Go over to <code>ui.js</code> and add the <code>menuBar</code> component.
<pre><code><div class="code-block">var React = require('react');
var Astarisx = require('astarisx');
var cvm = require('../viewModels/cvm');

var MenuBar = require('./menuBar');

var UI = React.createClass({
  mixins: [Astarisx.mixin.ui],
  componentWillMount: function(){
    this.initializeAppContext({ 
      controllerViewModel: cvm
    });
  },

  render: function(){
    console.log('Application State --> ', this.state.appContext);
    return (&lt;div&gt;
      &lt;MenuBar /&gt;
    &lt;/div&gt;);
  }
});
module.exports = UI;</div></code></pre>
A Menu Bar should appear at the top of the page.</p>
<p>Quickly create the other component files in the <code>views</code> directory and place the following code in each of them, ensuring that you replace the <code>displayName</code> property with the name of the component.
<pre><code><div class="code-block">var React = require('react');

var Component = React.createClass({

  displayName: 'MenuBar',
  render: function(){

    return (
      &lt;div&gt;Placeholder&lt;/div&gt;
    );
  }
});

module.exports = Component;</div></code></pre>
We will add to this code as we go. But for now open <code>ui.js</code> and add the Navigation and Details components. Your UI component should look something like this:
<pre><code><div class="code-block">var React = require('react');
var Astarisx = require('astarisx');
var cvm = require('../viewModels/cvm');

var MenuBar = require('./menuBar');
var Nav = require('./navigation');
var Details = require('./details');

var UI = React.createClass({
  mixins: [Astarisx.mixin.ui],
  componentWillMount: function(){
    this.initializeAppContext({ 
      controllerViewModel: cvm
    });
  },

  render: function(){
    console.log('Application State --> ', this.state.appContext);
    return (&lt;div&gt;
      &lt;MenuBar /&gt;
      &lt;div className="container"&gt;
        &lt;div className="row"&gt;
          &lt;div className="col-md-4"&gt;
            &lt;Nav /&gt;
          &lt;/div&gt;
          &lt;div className="col-md-8"&gt;
            &lt;Details /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div>);
  }
});
module.exports = UI;</div></code></pre>
Let's start adding some code to the Navigation component. The Navigation component will comprise a list of people, that we can click on that will help us navigate between people, and it will also have an input, that will allow us to add new people. Let's add the list first. Open <code>navigation.js</code> add a reference to the PersonList component called <code>PersonList</code> and update the render function with the following code.
<pre><code><div class="code-block">render: function(){
  return (
    &lt;div&gt;&lt;PersonList /&gt;&lt;/div&gt;
  );
}</div></code></pre>
That's it for now, we'll come back and add the input field later. Let's open <code>personListItem.js</code> and replace the render function with the code below.
<pre><code><div class="code-block">render: function() {
  var person = this.props.person;
  return (
    &lt;a className="list-group-item"
      href="#"&gt;{person.firstName + " " + person.lastName}
      &lt;span className="glyphicon glyphicon-trash pull-right"&gt;&lt;/span&gt;
    &lt;/a&gt;
  );
}</div></code></pre>
Now open <code>personList.js</code> and reference Astarisx and the PersonListItem component and add the following code
<pre><code><div class="code-block">mixins: [Astarisx.mixin.view],
render: function() {
  var persons = this.state.appContext.persons;
  var collection = persons.collection;
  var list = collection.map(function(person){
    return (
      &lt;PersonListItem
        key={person.id}
        person={person} /&gt;
    );
  });
  return (
    &lt;div className="list-group"&gt;
      {list}
    &lt;/div&gt;
  );
}</div></code></pre>
Let's take a moment and look at what's going on here. Within the PersonList component we reference Astarisx and mix in <code class="wrap">Astarisx.mixin.view</code>. The transforms PersonList from a regular React component into an Astarisx View. The PersonList component has become <b>a fully self contained component.</b> It does not require state to be passed via props, as all the state is held within the <code>appContext</code> object, which was appended to the component's state object when <code class="wrap">Astarisx.mixin.view</code> was mixed in. <code>appContext</code> has a reference to the <code>persons</code> data context that was exposed through the ControllerViewModel It will always hold the most current state and is the <b>Single Source of Truth</b> for your application's data.</p>
<p>So within the render function we are able to access the entire Application's Data Context. For now, we're only interested in the <code>persons</code> data context, so we get a reference to it and iterate over the collection to populate our list.</p>
<p>Let's update the Details component. The Details component, will display a form with a person's information and a list of hobbies using the Hobby List component. First we'll add the PersonForm.</p>
<p>Open <code>details.js</code> and reference Astarisx, then mixin in the view as you did for the PersonList then replace the render function with the code below.
<pre><code><div class="code-block">render: function() {
  var persons = this.state.appContext.persons;
  var current = persons.selectedPerson;

  return (
    &lt;div&gt;
      &lt;form className="form-horizontal" role="form"&gt;
        &lt;div className="form-group"&gt;
            &lt;label className="col-md-2 control-label"&gt;Name&lt;/label&gt;
            &lt;div className="col-md-3"&gt;
              &lt;input className="form-control" type="text" 
                value={current.fullName} /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className="form-group"&gt;
            &lt;label className="col-md-2 control-label"&gt;Occupation&lt;/label&gt;
            &lt;div className="col-md-3"&gt;
              &lt;input className="form-control" type="text"
                value={current.occupation} /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className="form-group"&gt;
            &lt;label className="col-md-2 control-label"&gt;Gender&lt;/label&gt;
            &lt;div className="col-md-3"&gt;
              &lt;div className="radio"&gt;
              &lt;label&gt;
                &lt;input type="radio" 
                  value="male"
                  checked={current.gender === 'male'} /&gt;
                Male
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className="radio"&gt;
              &lt;label&gt;
                &lt;input type="radio"
                  value="female"
                  checked={current.gender === 'female'} /&gt;
                Female
              &lt;/label&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className="form-group"&gt;
            &lt;label className="col-md-2 control-label"&gt;Birthday&lt;/label&gt;
            &lt;div className="col-md-3"&gt;
              &lt;input className="form-control" type="text"
              placeholder="yyyy-mm-dd"
              value={current.dob} /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className="form-group"&gt;
            &lt;label className="col-md-2 control-label"&gt;Age&lt;/label&gt;
            &lt;div className="col-md-3"&gt;
              &lt;div&gt;
                {current.age}
              &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</div></code></pre>
Before we reference the PersonForm in our Details component we need to make some changes to our ViewModel and Model. You will notice that we reference a field on the <code>persons</code> data context called <code>selectedPerson</code>, we will need to add this to our <code>personsViewModel</code>. This field will hold the currently selected Person model. We also need to add two additional fields to our Person Model. The <code>fullName</code> field, which will display the person's full name and the <code>age</code> field, which is a calculated field based on the <code>dob</code> (data of bith) field.</p>
<p>Open the <code>persons.js</code> file located in the <code>viewModels</code> directory and add the <code>selectedPerson</code> field.
<pre><code><div class="code-block">selectedPerson: {
  kind: 'instance',
  get: function() {
    return this.$state.selectedPerson;
  }
},</div></code></pre>
We only need a getter, because we will be setting this field via a function. We have also used a new <code>kind</code> attribute called <code>instance</code>. This indicates to Astarisx that an Astarisx Model will be stored in this field. Add the following code function to select a person.
<pre><code><div class="code-block">selectPerson: function(id){
  var person;

  for (var i = this.collection.length - 1; i >= 0; i--) {
    if(this.collection[i].id === id){
      person = new Person(this.collection[i]);
      break;
    }
  }
  this.setState({
    selectedPerson: person
  });
}</div></code></pre>
In the function above we loop through the persons collection and test to see if the passed in <code>id</code> matches any of our person id's. If we find a match we create a new Person and assign it to <code>person</code> and break out of the loop. If we don't find a match then the <code>person</code> remains <code>undefined</code>. We then take whatever is stored in <code>person</code> and pass it to <code>setState</code>. This will transition the <code>persons</code> data context to the next state and the <code>selectedPerson</code> field will then hold the new value.</p>
<p><b>n.b. A very important point to note here is that the <code>selectedPerson</code> is not the same object as the one stored in the collection. We have stored a totally new object in <code>selectedPerson</code>. Any changes to <code>selectedPerson</code> or the equivalent person in the collection will not be reflected in the other. I show how everything is kept in sync when we discuss updating models.</b></p>
<p>Let's update the View to utilize this code. We select persons using the PersonList component, so open <code>personList.js</code> and locate the PersonListItem component and add a prop called <code>person</code> and pass it <code>persons</code>. This will make the <code>persons</code> data context available to PersonsItemList. Open <code>personsItemList.js</code> and add the following code.
<pre><code><div class="code-block">handleSelection: function(e){
  e.preventDefault();
  this.props.persons.selectPerson(this.props.person.id);
}</div></code></pre> and update the render function with this
<pre><code><div class="code-block">render: function() {
  var person = this.props.person;
  var persons = this.props.persons;
  var selected = persons.selectedPerson && (person.id === persons.selectedPerson.id);
  return (
    &lt;a 
      onClick={this.handleSelection}
      className={selected ? "list-group-item active" : "list-group-item"} 
      href="#"&gt;{person.firstName + " " + person.lastName}
      &lt;span className="glyphicon glyphicon-trash pull-right"&gt;&lt;/span&gt;
    &lt;/a&gt;
  );
}</div></code></pre>
Select a person from the list and it should get highlighted.</p>
<p><em>If you've been following along, now is a good time to inspect the browser's javascript console. If you still have the console.log code in the UI component, you'll notice that every time you select a person, a new object is sent to the console. This is how Astarisx works. Go ahead poke around the object and inspect the data context fields.</em></p>













            <!-- <h2 class="content-subhead" id="#tips">Tips</h2>
            <h2 class="content-subhead" id="#videos">Videos</h2>
            <h2 class="content-subhead" id="#resources">Resources</h2> -->

            
        </div>
    </div>
</div>



<script src="../lib/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="js/ui.js"></script>
<script src="../lib/smooth-scroll.js"></script>
<script>
    smoothScroll.init({
      speed: 1000, // Integer. How fast to complete the scroll in milliseconds
    easing: "easeInOutCubic", // Easing pattern to use
    // updateURL: false, // Boolean. Whether or not to update the URL with the anchor hash on scroll
    // offset: 80, // Integer. How far to offset the scrolling anchor location in pixels
    // callbackBefore: function ( toggle, anchor ) {}, // Function to run before scrolling
    // callbackAfter: function ( toggle, anchor ) {} // Function to run after scrolling
    });
</script>


</body>
</html>
