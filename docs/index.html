<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Astarisx Documentation</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
    <!--<![endif]-->

</head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>

    <div id="menu">
        <div class="pure-menu pure-menu-open">
            
            <a class="pure-menu-heading" href="../index.html"><span class="fa fa-arrow-left"></span>Astarisx</a>

            <ul>
                <li><a href="#overview">Overview</a></li>
                <li class="sub"><a href="#mvvm">MVVM Pattern</a></li>
                <li class="sub"><a href="#anatomy">Application Anatomy</a></li>
                <li class="sub"><a href="#dataflow">Unidirectional Data Flow</a></li>
                <li><a href="#guide">Guide</a>
                    
                </li>
                <!-- <li class="menu-item-divided pure-menu-selected">
                    <a href="#">Services</a>
                </li> -->
                <li>
                    <a href="#api">API</a>
                </li>
                <li>
                    <a href="#support">Support</a>
                </li>
                <li>
                    <a href="#browser">Browser Support</a>
                </li>
                <li>
                    <a href="#">License</a>
                </li>
            </ul>
        </div>
    </div>

    <div id="main">
        <div class="header">
            <h1>Astarisx Documentation</h1>
            <h2>v0.10.0</h2>
        </div>

        <div class="content">
            
            <h2 class="content-subhead"><a name="overview">Overview</a></h2>
             <h3 class="content-subhead"><a name="mvvm">MVVM Pattern</a></h3>
            <p>
                Astarisx helps implement the Model-View-ViewModel pattern, which is a specialization of the <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> developed by Microsoft in 2005 to leverage WPF and Silverlight technologies. John Gossman, one of the Architects of WPF and Silverlight at Microsoft during that time, coined the term. <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">WPF Apps With The Model-View-ViewModel Design Pattern</a> by Josh Smith, explains the pattern and its history if you're interested. Another article I would recommend is Addy Osmani's <a href="http://addyosmani.com/blog/understanding-mvvm-a-guide-for-javascript-developers/">Understanding MVVM â€“ A Guide For JavaScript Developers</a>. He does a great job at explaining MVVM for the JavaScript developer.

                Anyway, what does this mean for Astarisx. Well, in a nut shell, the MVVM pattern allows you to write Business Logic that is completely sepearate from the View.

                A quote from WPF Apps With The Model-View-ViewModel Design Pattern summarizes MVVM nicely.
                </p>
                <blockquote>
                    <p>
                        ... a ViewModel does not need a reference to a view. The view binds to properties on a ViewModel, which, in turn, exposes data contained in model objects and other state specific to the view. The bindings between view and ViewModel are simple to construct because a ViewModel object is set as the DataContext of a view. If property values in the ViewModel change, those new values automatically propagate to the view via data binding. When the user clicks a button in the View, a command on the ViewModel executes to perform the requested action. The ViewModel, never the View, performs all modifications made to the model data. The view classes have no idea that the model classes exist, while the ViewModel and model are unaware of the view. In fact, the model is completely oblivious to the fact that the ViewModel and view exist. This is a very loosely coupled design, which pays dividends in many ways ...
                    </p>
                    <footer>
                        <cite><a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">Josh Smith</a></cite>
                    </footer>
                </blockquote>
                <p>
                In addition to the above.
                </p>
                <blockquote>
                    <p>... the [ViewModel] will observe the view and respond to events by changing any appropriate state and reloading the entire view.</p>
                    <footer>
                        <cite><a href="http://martinfowler.com/eaaDev/PresentationModel.html">Martin Fowler</a></cite>
                    </footer>
                </blockquote>
                <p>
                    So in the context of Astarisx, React components act as the View, "data binding" is one-way and a "command" on the ViewModel is simply referred to as an Action.

                    Astarisx also includes a specialized ViewModel, referred to as the ControllerViewModel. It determines which ViewModels are exposed to the View.
                </p>
            <h3 class="content-subhead"><a name="anatomy">Application Anatomy</a></h3>
            <div class="pure-g">
                <div class="pure-u-1">
                    <img class="pure-img-responsive" src="../img/common/Astarisx.png" alt="Anatomy">
                </div>
            </div>
            <h4 class="content-subhead"><a href="#concepts_models" name="concepts_models">Models</a></h4>
            <p>
                No respectable pattern can be defined without including a Model. Yes, I know, you don't really need Models in React Applications. But these Models are special and will really help simplify how your React application interacts with your data.

So, for those unfamiliar with the concept, a Model is a abstraction of your application's data domain. What this means is that a Model represents a real entity, like a Person, Bank Account or Shopping Cart Item and it encapsulates the current state of that entity. Sometimes Models map nicely to a record/object in a data store, but more often then not, they don't.

Within a Model you can add business logic, such as saving and field validation and other Model specific logic. I personally try to keep the Model as lean as possible and only use it to present data. But that's a personal preference and not a requirement.

Now I said that Astarisx Models are special. And they are. Astarisx Models are immutable. Meaning they can't be changed after they've been created. This ensures that the View, or any other part of the application, dosen't go and change (mutate) an object they weren't supposed to, breaking the application and causing bugs.

That's not to say that you can't change your data, you can. Astarisx makes it easy. You won't even know you're using immutable objects. Essentially, a Model's fields are exposed to the View and to update a Model you simply assign the new value to the field. For example to update a Person's name you would write something like this.state.appContext.people.currPerson.name = "Fred". Then the Model gets updated and the Application State is transitioned to the new state which includes your updated Model.

A Model has no knowledge of the View or ViewModels. Whenever a Model changes state, a ViewModel is notified. It receives the model's new state and handles transitioning the model to the next state. You can read more about that in Working with Models and Responding to Model Changes.
            </p>
            <h4 class="content-subhead"><a href="#concepts_cvm" name="concepts_cvm">The ControllerViewModel</a></h4>
            <p>
                Every Astarisx application will have a ControllerViewModel, which is a specilialized ViewModel. It's responsibility is to manage and store Application State. This is where you define application level logic. The sort of things you might define in the ControllerViewModel would be application navigation, undo functionality or the application's online or busy status.

                All methods and fields in the ControllerViewModel are exposed to the View. It also determines which ViewModels are exposed, as Data Contexts, to the View essentially defining the Application's Data Context. The Application Data Context is available to all Views and always holds the most current version of the Application's state. A View can interact with the Application Data Context, invoking Actions which are subsequently handled by the appropriate Model, ViewModel or the ControllerViewModel.

                <!-- See ControllerViewModel -->
            </p>
            <h4 class="content-subhead"><a href="#concepts_viewModels" name="concepts_viewModels">ViewModels</a></h4>
            <p>
                A ViewModel is where you define Business Logic and store View State. All methods and fields defined in a ViewModel are visible in the View via the Application Data Context. A ViewModel is also the responsible for exposing Models, and consequently their methods and fields, to the View.

                It is common practice, when applying the Model-View-ViewModel pattern, to have a one to one relationship between a View and a ViewModel (i.e. one ViewModel represents a specific View's model, hence the name ViewModel). However, Astarisx doesn't require this. It is possible to have multiple Views share one or more ViewModels.

                The associated methods, fields and Models exposed by a ViewModel to the View, is referred to as a Data Context. This Data Context, forms part of the Application's Data Context and will always hold the most current state. A View interacts with a Data Context, invoking Actions, which are subsequently handled by the appropriate Model, ViewModel or ControllerViewModel.

                <!-- See ViewModels -->
            </p>
            <h4 class="content-subhead"><a href="#concepts_ui" name="concepts_ui">The UI Container</a></h4>
            <p>
                React uses a single component to host all of the application's components. This is the component that is passed into <code>React.renderComponent</code> to initialize the application and is at the apex of the component hierarchy. Astarisx refers to this component as the UI Container. The UI Container can hold regular React components and/or Astarisx Views. The UI Container receives a copy of the entire Application Data Context whenever there is a state change, but can be configured not to if performance optimisation is required.
            </p>
            <h4 class="content-subhead"><a href="#concepts_views" name="concepts_views">Views</a></h4>
            <p>
                An Astarisx View is a self contained React component. They differ from regular React components in that they are stateless and completely decoupled from their Owner. Every View has its own copy of the Application Data Context. Astarisx is capable of displaying multiple Views in the UI at any one time. These Views are also capable and most likely to contain any number of Views themselves.

                An Astarisx View is free to move around, within the application, without breaking functionality. It has its own copy of the Application Data Context and receives a new copy whenever there is a state change. State change notifications are sent to Mounted Views and can be easily configured for UI performance optimization, to only notify specific Views when specific state changes occur.

                <!-- See Views -->
            </p>
            <h4 class="content-subhead"><a href="#concepts_stateManager" name="concepts_stateManager">State Manager</a></h4>
            <p>
                Astarisx takes on the responsibility of storing and managing the Application's State. Models, ViewModels and the ControllerViewModel store and manager their own state. The State Manager merges their state and transtions the application to the next state, the output being the Application Data Context. The State Manager will then notify the Views of the state change and pass them the Application Data Context in the new state. The State Manager is a system object. You don't need to create one of these.
                <!-- See Views -->
            </p>
           
            <h3 class="content-subhead"><a name="dataflow">Unidirectional Data Flow</a></h3>
            <p>Astarisx application data flows are unidirectional. Data, or state, flows out through the ControllerViewModel and ViewModels into the State Manager. The State Manager merges this state with the current Application State, effectively transitioning the Application Data Context to the next state. The State Manager notifies any registered Views that state has changed and sends them the new Application Data Context. The Views propagate any changes down through to its components which gets reflected in the UI. A View will invoke Actions on the Application Data Context, usually via User interactions on the UI, which get handled by the relevant Model, ViewModel or ControllerViewModel. The ControllerViewModel and/or Viewmodels process these actions and transition their Data Context to the next State. Once again, this state is passed to the State Manager, which transitions the Application Data Context to the next state and notifies the Views.</p>
            <div class="pure-g">
                <div class="pure-u-1-4">
                </div>
                <div class="pure-u-1-4">
                </div>
                <div class="pure-u-1-4">
                </div>
                <div class="pure-u-1-4">
                </div>
            </div>
            <h2 class="content-subhead"><a name="guide">Guide</a></h2>
            <h2 class="content-subhead"><a name="api">API</a></h2>
            <p>
                Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
            </p>
            <h2 class="content-subhead"><a name="support">Support</a></h2>
            <h2 class="content-subhead"><a name="browser">Browser Support</a></h2>
            <p>Most ECMAScript 5 compliant browsers.</p>

<p><b>IE8 and below is not supported.</b></p>

<p><b>IE9 and below is not supported if the pushState option is enabled.</b></p>
            <h2 class="content-subhead"><a name="api">License</a></h2>
            <h3 class="content-subhead">The MIT License (MIT)</h3>

<h4 class="content-subhead">Copyright &copy 2014-2015 Entrendipity Pty. Ltd.</h4>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        </div>
    </div>
</div>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="js/ui.js"></script>


</body>
</html>
